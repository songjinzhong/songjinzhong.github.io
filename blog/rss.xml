<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>渔人</title>
    <link>http://yuren.space/</link>
    <atom:link href="/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>渔人的网站</description>
    <pubDate>Wed, 05 Oct 2016 15:24:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>SQL 注入详解</title>
      <link>http://yuren.space/blog/2016/10/01/SQL%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</link>
      <guid>http://yuren.space/blog/2016/10/01/SQL%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Sat, 01 Oct 2016 13:09:44 GMT</pubDate>
      <description>
      
        SQL 注入 详解
      
      </description>
      
      <content:encoded><![CDATA[<p>从今年(2016) 6 月初来到南京( 841 研究所)实习，到现在四个月过去了，期间主要的工作还是研究 WEB 安全，编程语言是 Python，常用到正则表达式，对 HTTP 的协议也非常清晰。</p><a id="more"></a><p>刚过来的时候，研究的主要是 SQL 注入，因为之前没有搞过安全，所有费了好长一段时间对 SQL 注入基本知识进行了解。<strong>这篇文章并不是什么很深入的技术博客，或许应该叫它‘ SQL注入扫盲 ’</strong>。</p><h2 id="关于-SQL-Injection"><a href="#关于-SQL-Injection" class="headerlink" title="关于 SQL Injection"></a>关于 SQL Injection</h2><p>SQL Injection 就是通过把恶意的 SQL 命令插入到 Web 表单让服务器执行，最终达到欺骗服务器或数据库执行恶意的 SQL 命令。</p><p>学习 SQL 注入，首先要搭一个靶机环境，我使用的是 <a href="https://www.owasp.org/index.php/GPC_Project_Details/OWASP_BWA_Project" target="_blank" rel="external">OWASP BWA</a>，感兴趣的可以去官网下载一个安装，除了 SQL 注入，很多靶机环境都可以在 BWA 中找到，它专门为 <a href="https://github.com/zaproxy/zaproxy" target="_blank" rel="external">OWASP ZAP</a> 渗透工具设计的。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="perl">$id = $_GET[<span class="string">'id'</span>];
$getid = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id'"</span>;
$result = mysql_query($getid) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );
$num = mysql_numrows($result);</code></pre></td></tr></table></figure><p>这是一个很简单的 PHP代码，从前台获得 <code>id</code> 的值，交给数据库来执行，把结果返回给前台。</p><p>比如我们在 OWASP 里输入 <code>id = 1</code>，点击 Submit，返回结果如下：</p><p><img src="/content/images/2016/10/p1.png" alt=""></p><p>稍微懂一点后台或者数据库的人都知道，上面的那段代码是有严重问题的，<strong>没有对 id 的值进行有效性、合法性判断</strong>。也就是说，我们在 submit 输入框输入的如何内容都会被提交给数据库执行，比如在输入框输入<code>1&#39; or &#39;1&#39;=&#39;1</code>，执行就会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="sql">//原先要在数据库中执行的命令
<span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> user_id = <span class="string">'1'</span>
//变成
<span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> user_id = <span class="string">'1'</span> <span class="keyword">or</span> <span class="string">'1'</span>=<span class="string">'1'</span></code></pre></td></tr></table></figure><p><strong>注意一下单引号，这是 SQL 注入中非常重要的一个地方，所以注入代码的最后要补充一个 <code>&#39;1&#39;=&#39;1</code>让单引号闭合。</strong></p><p>由于 or 的执行，会把数据库表 users 中的所有内容显示出来，</p><p><img src="/content/images/2016/10/p2.png" alt=""></p><p>下面对三种主要的注入类型进行介绍。</p><h2 id="Boolean-based-原理分析"><a href="#Boolean-based-原理分析" class="headerlink" title="Boolean-based 原理分析"></a>Boolean-based 原理分析</h2><p>首先不得不讲SQL中的AND和OR<br>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。<br>AND:返回第一个条件和第二个条件都成立的记录。<br>OR:返回满足第一个条件或第二个条件的记录。<br>AND和OR即为集合论中的交集和并集。<br>下面是一个数据库的查询内容。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select * from students;
+-------+-------+-----+</span>
<span class="section">| id    | name  | age |
+-------+-------+-----+</span>
| 10056 | Doris |  20 |
| 10058 | Jaune |  22 |
<span class="section">| 10060 | Alisa |  29 |
+-------+-------+-----+</span>
3 rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>1)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select * from students where TRUE ;
+-------+-------+-----+</span>
<span class="section">| id    | name  | age |
+-------+-------+-----+</span>
| 10056 | Doris |  20 |
| 10058 | Jaune |  22 |
<span class="section">| 10060 | Alisa |  29 |
+-------+-------+-----+</span>
3 rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>2)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="oxygene">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">FALSE</span> ;
<span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</code></pre></td></tr></table></figure><p>3)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; SELECT * from students where id = 10056 and TRUE ;
+-------+-------+-----+</span>
<span class="section">| id    | name  | age |
+-------+-------+-----+</span>
<span class="section">| 10056 | Doris |  20 |
+-------+-------+-----+</span>
1 row in set (0.00 sec)</code></pre></td></tr></table></figure><p>4)</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="oxygene">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> id = <span class="number">10056</span> <span class="keyword">and</span> <span class="keyword">FALSE</span> ;
<span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</code></pre></td></tr></table></figure><p>5)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; selcet * from students where id = 10056 or TRUE ;
+-------+-------+-----+</span>
<span class="section">| id    | name  | age |
+-------+-------+-----+</span>
| 10056 | Doris |  20 |
| 10058 | Jaune |  22 |
<span class="section">| 10060 | Alisa |  29 |
+-------+-------+-----+</span>
3 rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>6)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select * from students where id = 10056 or FALSE ;
+-------+-------+-----+</span>
<span class="section">| id    | name  | age |
+-------+-------+-----+</span>
<span class="section">| 10056 | Doris |  20 |
+-------+-------+-----+</span>
1 row in set (0.00 sec)</code></pre></td></tr></table></figure><p><strong>会发现and 1=1 , and 1=2 即是 and TRUE , and FALSE 的变种。</strong><br><strong>这便是最基础的boolean注入,以此为基础你可以自由组合语句。</strong></p><p>字典爆破流</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="oxygene"><span class="keyword">and</span> exists(<span class="keyword">select</span> * <span class="keyword">from</span> ?)     <span class="comment">//?为猜测的表名</span>
<span class="keyword">and</span> exists(<span class="keyword">select</span> ? <span class="keyword">from</span> x)     <span class="comment">//?为猜测的列名</span></code></pre></td></tr></table></figure><p>截取二分流</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="sql">and (length((<span class="keyword">select</span> schema_name <span class="keyword">from</span> information_schema.schemata <span class="keyword">limit</span> <span class="number">1</span>))&gt;?)       //判断数据库名的长度
<span class="keyword">and</span> (<span class="keyword">substr</span>((<span class="keyword">select</span> schema_name <span class="keyword">from</span> information_schema.schemata <span class="keyword">limit</span> <span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)&gt;<span class="string">'?'</span>)
<span class="keyword">and</span> (<span class="keyword">substr</span>((<span class="keyword">select</span> schema_name <span class="keyword">from</span> information_schema.schemata <span class="keyword">limit</span> <span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)&lt;<span class="string">'?'</span>)      //利用二分法判断第一个字符</code></pre></td></tr></table></figure><h3 id="Boolean-based总结"><a href="#Boolean-based总结" class="headerlink" title="Boolean-based总结"></a>Boolean-based总结</h3><p>根据前面的介绍，我们知道，对于基于Boolean-based的注入，<strong>必须要有一个可以正常访问的地址</strong>，比如http: //redtiger.labs.overthewire.org/level4.php?id=1 是一个可以正常访问的记录，说明id=1的记录是存在的，下面的都是基于这个进一步猜测。先来判断一个关键字keyword的长度，在后面构造<strong>id=1 and (select length(keyword) from table)=1</strong>，从服务器我们会得到一个返回值，如果和先前的返回值不一样，说明and后面的<strong>(select length(keyword) from table)=1返回false</strong>，keyword的长度不等于1。继续构造直到id=1 and (select length(keyword) from table)=15返回true，说明keyword的长度为15。</p><p><strong>为什么我们刚开始一定要找一个已经存在的id，其实这主要是为了构造一个为真的情况。Boolean-based就是利用查询结果为真和为假时的不同响应，通过不断猜测来找到自己想要的东西。</strong></p><p>对于keyword的值，mysql数据库可以使用substr(string, start, length)函数，截取string从第start位开始的length个字符串id=1 and (select substr(keyword,1,1) from table) =’A’，依此类推，就可以获得keyword的在数据库中的值。<br>Boolean-based的效率很低，需要多个请求才能确定一个值，尽管这种代价可以通过脚本来完成，在有选择的情况下，我们会优先选择其他方式。</p><h2 id="Error-Based-原理分析"><a href="#Error-Based-原理分析" class="headerlink" title="Error Based 原理分析"></a>Error Based 原理分析</h2><h3 id="关于错误回显"><a href="#关于错误回显" class="headerlink" title="关于错误回显"></a>关于错误回显</h3><p>基于错误回显的sql注入就是<strong>通过sql语句的矛盾性来使数据被回显到页面上</strong>。</p><p>所用到的函数</p><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="q"><span class="built_in">count</span>() 统计元祖的个数（相当于求和）
如<span class="keyword">select</span> <span class="built_in">count</span>(*) <span class="keyword">from</span> information_schema.<span class="built_in">tables</span>;  

<span class="built_in">rand</span>()用于产生一个<span class="number">0</span>~<span class="number">1</span>的随机数  

<span class="built_in">floor</span>()向下取整  

<span class="built_in">group</span> <span class="keyword">by</span> 依据我们想要的规矩对结果进行分组  

concat将符合条件的同一列中的不同行数据拼接，以逗号隔开</code></pre></td></tr></table></figure><h3 id="用于错误回显的sql语句"><a href="#用于错误回显的sql语句" class="headerlink" title="用于错误回显的sql语句"></a>用于错误回显的sql语句</h3><p><strong>第一种： 基于 rand() 与 group by 的错误</strong></p><p>利用group by part of rand() returns duplicate key error这个bug，关于rand()函数与group by 在mysql中的错误报告如下：</p><p><strong>RAND() in a WHERE clause is re-evaluated every time the WHERE is executed.<br>You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times.</strong></p><p>这个bug会爆出duplicate key这个错误，然后顺便就把数据偷到了。<br>公式：<strong>username=admin’ and (select 1 from (select count(<em>), concat(floor(rand(0)</em>2),0x23,(你想获取的数据的sql语句))x from information_schema.tables group by x )a) and ‘1’ = ‘1</strong></p><p><strong>第二种： XPATH爆信息</strong></p><p>这里主要用到的是ExtractValue()和UpdateXML()这2个函数，由于mysql 5.1以后提供了内置的XML文件解析和函数，所以这种注入只能用于5.1版本以后使用</p><p>查看sql手册</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="crmsh">语法：EXTRACTVALUE (XML_document, XPath_string);
第一个参数：XML_document是<span class="keyword">String</span>格式，为XML文档对象的名称，文中为Doc
第二个参数：XPath_string (<span class="keyword">Xpath</span>格式的字符串) ，如果不了解<span class="keyword">Xpath</span>语法，可以在网上查找教程。</code></pre></td></tr></table></figure><p>作用：从目标XML中返回包含所查询值的字符串</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="ceylon">语法:UPDATEXML (XML<span class="number">_</span>document, XPath<span class="number">_</span>string, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);
第一个参数：XML<span class="number">_</span>document是String格式，为XML文档对象的名称，文中为Doc
第二个参数：XPath<span class="number">_</span>string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。
第三个参数：<span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>，String格式，替换查找到的符合条件的数据</code></pre></td></tr></table></figure><p>作用：改变文档中符合条件的节点的值</p><p>现在就很清楚了，我们只需要不满足XPath_string(Xpath格式)就可以了，但是由于这个方法只能爆出32位，所以可以结合mid来使用<br>公式1：<strong>username=admin’ and (extractvalue(1, concat(0x7e,(你想获取的数据的sql语句)))) and ‘1’=’1</strong><br>公式2：<strong>username=admin’ and (updatexml(1, concat(0x7e,(你想获取的数据的sql语句)),1)) and ‘1’=’1</strong></p><p>基于错误回显的注入，总结起来就一句话，通过sql语句的矛盾性来使数据被回显到页面上，但有时候局限于回显只能回显一条，导致基于错误的注入偷数据的效率并没有那么高，但相对于布尔注入已经提高了一个档次。</p><h2 id="union-query-injection"><a href="#union-query-injection" class="headerlink" title="union query injection"></a>union query injection</h2><p>要了解union query injection，首先得了解union查询，union用于合并两个或更多个select的结果集。比如说</p><pre><code>SELECT username, password FROM account;
</code></pre><p>结果是</p><p><code>admin 123456</code></p><pre><code>SELECT id, title FROM article
</code></pre><p>的结果是</p><p><code>1 Hello, World</code></p><pre><code>SELECT username, password FROM account
UNION 
SELECT id, title FROM article
</code></pre><p>的结果就是</p><p><code>admin 123456</code></p><p><code>1 Hello, World</code></p><p>比起多重嵌套的boolean注入，union注入相对轻松。因为，union注入可以直接返回信息而不是布尔值。<strong>前面的介绍看出把union会把结果拼拼到一起，所有要让union前面的查询返回一个空值，一般采用类似于id=-1的方式。</strong></p><p>1)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select name from students where id = -1 union select schema_name from information_schema.schemata;   //数据库名  
+--------------------+</span>
<span class="section">| name               |
+--------------------+</span>
| information<span class="emphasis">_schema |
| mysql              |
| performance_</span>schema |
| rumRaisin          |
| t3st               |
<span class="section">| test               |
+--------------------+</span>
6 rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>2)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select name from students where id = -1 union select table_name from information_schema.tables where table_schema='t3st';    //表名
+----------+</span>
<span class="section">| name     |
+----------+</span>
| master   |
<span class="section">| students |
+----------+</span>
2   rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>3)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="asciidoc"><span class="section">mysql&gt; select name from students where id = -1 union select column_name from information_schema.columns where table_name = 'students' ;     //列名
+------+</span>
<span class="section">| name |
+------+</span>
| id   |
| name |
<span class="section">| age  |
+------+</span>
3 rows in set (0.00 sec)</code></pre></td></tr></table></figure><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。<strong>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</strong></p><p>举个例子，还以最开始的 OWASP 为基础，返回了两个值分别是 first_name 和 sur_name，可想而知，服务器在返回数据库的查询结果时，就会把结果中的第一个值和第二个值传给 first_name 和 sur_name，多了或少了，都会引起报错。</p><p>所以你如果想要使用union查询来进行注入，你首先要猜测后端查询语句中查询了多少列，哪些列可以回显给用户。</p><p>猜测列数</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="crystal">-<span class="number">1</span> <span class="class"><span class="keyword">union</span> <span class="title">select</span> 1</span>
-<span class="number">1</span> <span class="class"><span class="keyword">union</span> <span class="title">select</span> 1,2</span>
-<span class="number">1</span> <span class="class"><span class="keyword">union</span> <span class="title">select</span> 1,2,3</span>
/<span class="regexp">/直到页面正常显示</span></code></pre></td></tr></table></figure><p>比如这条语句</p><pre><code>-1 UNION SELECT 1,2,3,4
</code></pre><p>如果显示的值为3和4，表示该查询结果中有四列，并且第三列和第四列是有用的。则相应的构造union语句如下</p><pre><code>-1 UNION SELECT 1,2,username,password FROM table
</code></pre><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>SQL 注入大概有5种，还有两种分别是 Stacked_queries(基于堆栈)和 Time-based blind(时间延迟)，堆栈就是多语句查询，用 ‘;’ 把语句隔开，和 union 一样；时间延迟就是利用 sleep() 函数让数据库延迟执行，偷数据的速度很慢。(还有一个第六种，内联注入，但和前面涉及的内容有所重叠，就不单独来讨论了)</p><p><strong>引用说明</strong>，自己之前研究 SQL 注入的时候，也是一点一点摸索的，本博客的大部分内容是来自于公司内网的服务器中(公司定期考核，看你都干了什么)。当时因为是内网，就没有做引用，现在想找到这些引用的文章也很困难，见谅。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/10/01/SQL%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JS 进阶之路 : 原型链</title>
      <link>http://yuren.space/blog/2016/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <guid>http://yuren.space/blog/2016/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <pubDate>Wed, 28 Sep 2016 12:20:40 GMT</pubDate>
      <description>
      
        JS 进阶 原型链
      
      </description>
      
      <content:encoded><![CDATA[<p>刚学习 JavsScript 的时候，感觉它有点混乱，以前接触 C++或 Java，好歹有个 class 来实现继承，JS 作为动态语言，结构只有对象，偶尔还来个闭包，this 什么的。</p><a id="more"></a><p>JS 中是有继承的，通过原型来实现，即 prototype，每个函数对象都有 prototype ，而每个对象都有 __proto__，prototype 和 __proto__ 是实现原型链的根本。</p><h2 id="prototype-实现继承"><a href="#prototype-实现继承" class="headerlink" title="prototype 实现继承"></a>prototype 实现继承</h2><p>先看一个简单的例子，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;&#125;;
person.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can say!'</span>)
&#125;;
<span class="keyword">var</span> student = <span class="keyword">new</span> person();
student.Say(); <span class="comment">//'I can say!'</span></code></pre></td></tr></table></figure><p>这段代码没问题，对于 <code>new</code> 初始化实际上之前的文章已经讨论过，有<a href="http://blog.yuren.space/bi-bao/" target="_blank" rel="external"> 3 个步骤</a>。</p><p>然后是下面的代码，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;
	<span class="keyword">this</span>.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(<span class="string">'Say!!!'</span>)
	&#125;
&#125;;
person.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can say!'</span>)
&#125;;
<span class="keyword">var</span> student = <span class="keyword">new</span> person();
student.Say(); <span class="comment">//'Say!!!'</span></code></pre></td></tr></table></figure><p>结果是 <code>Say!!!</code>，说明初始化的顺序：</p><ol><li>通过原型给对象添加的属性</li><li>通过构造器给对象添加的属性</li></ol><p>构造器内部的函数的优先级比原型的高，然后得出结论：</p><ol><li>使用对象的一个属性时，首先检查该对象本身是否有该属性，有则返回，没有则继续；</li><li>查看对象的原型是否有该属性，有则返回，没有则继续查看对象原型的原型，知道为 null，则返回 undefined。</li></ol><p>为了验证该结论的正确性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;
	<span class="keyword">this</span>.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(<span class="string">'Say!!!'</span>)
	&#125;
&#125;;
<span class="keyword">var</span> student = <span class="keyword">new</span> person();
person.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can say!'</span>)
&#125;;
student.Say(); <span class="comment">//'Say!!!'</span></code></pre></td></tr></table></figure><p>把初始化提前之后，同样是先访问对象本身。</p><h2 id="constructor-实现初始化"><a href="#constructor-实现初始化" class="headerlink" title="constructor 实现初始化"></a>constructor 实现初始化</h2><p>JS 中每个对象，都有一个名为constructor 的隐式属性，该属性是引用创建该属性的构造器。</p><p>比如说 <code>var student = new person()</code>，student 就有一个 constructor 指向 person()，我们在上个代码的最后添上:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="lua">console.log(student.constructor)
/*输出
<span class="function"><span class="keyword">function</span> <span class="title">person</span><span class="params">()</span></span>&#123;
	this.Say = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;
		console.log(<span class="string">'Say!!!'</span>)
	&#125;
&#125;
*/</code></pre></td></tr></table></figure><h2 id="原型链-proto"><a href="#原型链-proto" class="headerlink" title="原型链 __proto__"></a>原型链 __proto__</h2><p>__proto__ 是每个对象内部的一个属性，任何一个对象，<strong>当我们访问对象的一个属性时，如果对象本身不存在这个属性，会去 __proto__ 里找，如果还不在，去__proto__的__proto__找……这就是原型链。</strong></p><p>__proto__就像一个指针，指向父节点的 prototype。这下子前面的例子就很好理解了：</p><ol><li>person 是一个对象，student 继承 person，所以 student 的 __proto__指向person 的prototype；</li><li>访问 student.Say()，如果 student 有 Say() 属性，则返回；如果没有，则去__proto__里找，而__proto__指向父的 prototype，一直找下去。</li></ol><p><strong>之前在写原型链代码的时候碰到一个坑，实际上还是自己理解不深，</strong>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;
person.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can say!'</span>)
&#125;
<span class="keyword">var</span> student = <span class="keyword">new</span> person();
person.prototype.doHomework = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can do Homework!'</span>)
&#125;;
<span class="keyword">var</span> china_student = <span class="keyword">new</span> student();
china_student.Say();
china_student.doHomework();</code></pre></td></tr></table></figure><p>这样子写很明显是有问题的，我们是通过原型链来实现继承，而正确的写法应该是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;
person.prototype.Say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can say!'</span>)
&#125;
<span class="keyword">var</span> student = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;
student.prototype = <span class="keyword">new</span> person(); <span class="comment">//这一步原型链</span>
person.prototype.doHomework = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="string">'I can do Homework!'</span>)
&#125;;
<span class="keyword">var</span> china_student = <span class="keyword">new</span> student();
china_student.Say();
china_student.doHomework();</code></pre></td></tr></table></figure><p>下面附上 <a href="http://stackoverflow.com/questions/650764/how-does-proto-differ-from-constructor-prototype" target="_blank" rel="external">stackoverflow</a> 上一幅图，</p><p><img src="https://sfault-image.b0.upaiyun.com/87/be/87bedc7497759ef29844afab67f4c478_articlex" alt=""></p><p>从上图可以看出，prototype 为继承而生，constructor 实现初始化，而真正形成原型链的是 __proto__它是一个指向父节点原型的指针，共勉。</p><p><strong>参考</strong></p><blockquote><p>《JavaScript 忍者秘籍》</p><p><a href="https://segmentfault.com/a/1190000006711220" target="_blank" rel="external">关于<strong>proto</strong>和prototype的一些理解</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JS 进阶之路 : 闭包</title>
      <link>http://yuren.space/blog/2016/09/24/%E9%97%AD%E5%8C%85/</link>
      <guid>http://yuren.space/blog/2016/09/24/%E9%97%AD%E5%8C%85/</guid>
      <pubDate>Sat, 24 Sep 2016 02:50:37 GMT</pubDate>
      <description>
      
        JS 进阶 闭包
      
      </description>
      
      <content:encoded><![CDATA[<p>函数在 JavaScript 中是第一型对象，而闭包的使用使其变得非常灵活。闭包也算是 JS 中非常有特色的，好吧，先来说一下闭包的好处与缺点吧：</p><p><code>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</code><br><a id="more"></a></p><p>简单点说，闭包是一个作用域，这个作用域的对象是函数，即函数在创建时允许该自身函数<strong>访问并操作</strong>自身函数之外的变量，当然，对于自身函数内的变量必然是可以访问的。换句话说，闭包可以让函数访问所有变量和函数，只要这些变量和函数存在于该函数声明时的作用域内进行。</p><p>比如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><code class="javascript"><span class="comment">//全局可以访问</span>
<span class="keyword">var</span> outValue = <span class="string">'outValue'</span>;
<span class="keyword">var</span> fn;
<span class="function"><span class="keyword">function</span> <span class="title">outFunction</span>(<span class="params"></span>)</span>&#123;
	<span class="comment">//内部也可以访问</span>
	<span class="keyword">var</span> innerValue = <span class="string">'innerValue'</span>;
	<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(outValue); <span class="comment">//'outValue'</span>
		<span class="built_in">console</span>.log(innerValue); <span class="comment">//'innerValue'</span>
		<span class="built_in">console</span>.log(laterValue); <span class="comment">//'laterValue'</span>
	&#125;
	fn = innerFunction;
&#125;
outFunction();
<span class="built_in">console</span>.log(laterValue); <span class="comment">//'undefined'</span>
<span class="comment">//函数执行前申请的变量也可以访问</span>
<span class="keyword">var</span> laterValue = <span class="string">'laterValue'</span>;
fn();</code></pre></td></tr></table></figure><p>上面的例子可以说明三个事实：</p><ol><li>同一个作用域内，未赋值的变量不可访问(这和函数全作用域调用有所不同)</li><li>内部函数变量可以在闭包中使用</li><li>如果变量在函数执行前申明(比如laterValue)，作用域之外的变量也可以访问</li></ol><p>变量的提前申明，如下，<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="javascript"><span class="built_in">console</span>.log(hello) <span class="comment">//'undefined'</span>
<span class="keyword">var</span> hello = <span class="string">'hello'</span>;</code></pre></td></tr></table></figure><p></p><p>实际上，变量是提前申明，在闭包开始的时候，就已经申明变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> hello;
<span class="built_in">console</span>.log(hello) <span class="comment">//'undefined'</span>
hello = <span class="string">'hello'</span>;</code></pre></td></tr></table></figure><h3 id="用闭包实现访问私有变量"><a href="#用闭包实现访问私有变量" class="headerlink" title="用闭包实现访问私有变量"></a>用闭包实现访问私有变量</h3><p>闭包用来封装私有变量，当然，也可以构造一些方法来访问改变这些私有变量，这些方法和 Java 中的 set、get 原理是一样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;
	<span class="keyword">var</span> counts = <span class="number">0</span>;
	<span class="keyword">this</span>.getCounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		<span class="keyword">return</span> counts;
	&#125;;
	<span class="keyword">this</span>.addCounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		counts++;
	&#125;;
&#125;
<span class="keyword">var</span> test = <span class="keyword">new</span> fn();
test.addCounts();
<span class="built_in">console</span>.log(test.getCounts()); <span class="comment">//'1'</span></code></pre></td></tr></table></figure><p><code>counts</code> 的值变成了 1 ，可以通过 fn 提供的 <code>getCounts()</code>来访问。</p><p>对于<code>var test = new fn();</code>，对 test 做了如下操作：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="gauss">var test = &#123;&#125;;
test.__proto__ = <span class="function"><span class="keyword">fn</span>.prototype</span>;
<span class="function"><span class="keyword">fn</span>.<span class="keyword">call</span><span class="params">(test)</span></span>;</code></pre></td></tr></table></figure><p>如果 fn有参数的话，还需要把参数放到 call 函数里。至于__proto__，是有关于 JS 的原型链，后面的文章会写到。</p><h3 id="即时函数"><a href="#即时函数" class="headerlink" title="即时函数"></a>即时函数</h3><p>即时函数也是常见的闭包使用，类似<code>(function(){})()</code>，有时候还用 ! 或 + 放到<code>function(){}</code>前面，组成<code>!function(){}()</code>。</p><p>说到即时函数，使用最多的还是对循环进行处理，比如下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> buttons = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'button'</span>);
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++)&#123;
	buttons[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		alert(i);
	&#125;);
&#125;</code></pre></td></tr></table></figure><p>上面的代码点击 button，都只会弹出同一个 i 值，就是 i 的最终状态，即 i 的值等于<code>buttons.length</code>。</p><p>这个原因很好理解，这跟前面说的一样，就是 button 点击之后，函数才会执行，如果把执行函数当作闭包的话，i 是外部变量，<strong>闭包记住的都是变量的引用，而不是函数执行时的变量状态</strong>，所有访问变量 i 的都是 i 的最终状态。</p><p>用即时函数来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> buttons = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'button'</span>);
<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buttons.length; i++)&#123;
	!<span class="function"><span class="keyword">function</span>(<span class="params">now_i</span>)</span>&#123; <span class="comment">//用即时函数把 i 赋值给 now_i</span>
		buttons[now_i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
			<span class="comment">// 访问的now_i是闭包内的变量</span>
			alert(now_i);
		&#125;);
	&#125;(i);
&#125;</code></pre></td></tr></table></figure><p>即时函数也是闭包，执行的时候，会把当前的 i 值传递给当前闭包 now_i，当按钮被点击的时候，函数访问的不是最终的 i，而是当前闭包内的 now_i 值。这算是闭包一个非常有用的使用。</p><p>这篇文章应该早点写的，最近真的太忙了，近期还会写一篇关于 JS 中原型链的，共勉。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/09/24/%E9%97%AD%E5%8C%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>8 月实习总结</title>
      <link>http://yuren.space/blog/2016/09/16/8%E6%9C%88%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
      <guid>http://yuren.space/blog/2016/09/16/8%E6%9C%88%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Fri, 16 Sep 2016 15:04:24 GMT</pubDate>
      <description>
      
        实习 总结
      
      </description>
      
      <content:encoded><![CDATA[<p>在南京实习已经三个多月了，这段时间学到了不少知识，尤其是在 Web 安全这方面，我觉得这对我以后从事前端行业有很大的帮助，比如对 Http 协议、响应状态码等一些前端用到的知识有着非常深刻的理解。</p><a id="more"></a><p>目前公司里开发的语言是 Python，系统是 Ubuntu，项目用 GitLab 管理，经常用到正则表达式匹配。这四个对以后的路也有很大的帮助，比如 Python 这们语言和 JS 很像，在某些思路（比如函数作为第一对象）都极大的相似；Win虽然好用，却真的很丑陋，还是开源的 Linux 好用；关于 Git 自然不必多说；几乎所有的语言都支持正则表达式，而如果不去深入研究，也只是懂得其中的皮毛而已，根本不会体会到正则表达式的强大。</p><p>程序员的自我修养，学会解决问题的能力，在工作的过程中，难免会遇到一些稀奇古怪却很令人兴奋的 bug，通过 google baidu 并把它们解决。</p><h3 id="gitignore-文件不起作用"><a href="#gitignore-文件不起作用" class="headerlink" title=".gitignore 文件不起作用"></a>.gitignore 文件不起作用</h3><p>Git 中有时候有一些本地的文件，我们并不想把它们进行管理，例如一些 test 文件夹下面的测试用例，再或者 npm 管理的node_modules 文件夹，文件内容很大，还不如用户自己通过<code>npm install</code> 命令自己安装。这个时候可以在根目录下面建一个 .gitignore 文件，写入一些不想加入版本管理的文件或文件夹。</p><p>至于如何屏蔽一些文件或文件夹，网上的教程很多。我在使用的时候，出现了一个小问题，就是把需要屏蔽的文件加入到 .gitignore 中后失效，后来经过 google，发现是缓存中已经存在的原因。</p><p>大致的情况是这样的：</p><p>我平时用 Git 不喜欢用某些界面来管理，喜欢用 Git 命令行，感觉用习惯了也很酷。</p><p>我在项目中加入了一些 test 测试文件，放到 test 文件夹下面，然后一不小心，把它们加入到 cache 中(<code>git add .</code>)</p><p><img src="/content/images/2016/09/1.png" alt=""></p><p>这个时候我才想起来在 .gitignore 文件中加入屏蔽，<code>echo /test &gt;&gt;.gitignore</code>，为时已晚，通过 <code>git status</code>查看，发现</p><p><img src="/content/images/2016/09/2.png" alt=""></p><p>已经还是无法避免掉 test 文件夹，原因是已经在 git cache 中存在了，<a href="http://stackoverflow.com/questions/11451535/gitignore-not-working" target="_blank" rel="external">stackoverflow 提供了方法</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="sql">//在执行rm之前，特别强调要先 <span class="keyword">commit</span>，不然数据丢失
git rm -r <span class="comment">--cached .</span>
git <span class="keyword">add</span> .
git <span class="keyword">commit</span> -m <span class="string">"update .gitignore file"</span></code></pre></td></tr></table></figure><p>结果在执行 <code>git add .</code> 之后</p><p><img src="/content/images/2016/09/3.png" alt=""></p><p>解决！</p><h3 id="CSS-中的-inline-block"><a href="#CSS-中的-inline-block" class="headerlink" title="CSS 中的 inline-block"></a>CSS 中的 inline-block</h3><p>CSS元素分为块元素和行内元素，常见的块级元素有 div, p, ul, li, form, table, h1~h6, hr等，行内元素有 span, a, b, em, br, input, image, label, strong, textarea等。</p><p>无论块级元素还是行内元素，都可以通过设置 <code>display:inline-block;</code>的方式在行内以块级元素显示。但是有一个问题困扰我很就，如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span>
	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css">
		<span class="selector-tag">span</span>&#123;
			<span class="attribute">display</span>: inline-block;
			<span class="attribute">width</span>: <span class="number">100px</span>;
			<span class="attribute">height</span>: <span class="number">100px</span>;
			<span class="attribute">border</span>: <span class="number">1px</span> solid black;
			<span class="attribute">background</span>: blue;
		&#125;
	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">body</span>&gt;</span>
	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>
	<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/content/images/2016/09/4.png" alt=""></p><p>就像上图显示的那样，inline-block 元素之间有空隙，大致可以通过以下几种方法解决：</p><p><strong>设置父元素font-size : 0px;</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css">
	<span class="selector-tag">body</span>&#123;
		<span class="attribute">font-size</span>: <span class="number">0</span>;
	&#125;
	<span class="selector-tag">span</span>&#123;
		<span class="attribute">display</span>: inline-block;
		<span class="attribute">width</span>: <span class="number">100px</span>;
		<span class="attribute">height</span>: <span class="number">100px</span>;
		<span class="attribute">border</span>: <span class="number">1px</span> solid black;
		<span class="attribute">background</span>: blue;
	&#125;
</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></code></pre></td></tr></table></figure><p>span 元素的父元素是 body，这里设置body 的 font-size 为 0，看下效果：</p><p><img src="/content/images/2016/09/5.png" alt=""></p><p>但是这个效果有一个非常大的弊端，或者说这是一个非常蠢的解决方案，首先是它可能会在某些浏览器失效(好像已经修复了)，这个不管，然后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>
	<span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
	<span class="tag">&lt;<span class="name">span</span>&gt;</span>World<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span></code></pre></td></tr></table></figure><p><img src="/content/images/2016/09/7.png" alt=""></p><p><strong>修改 html 代码</strong></p><p>通过修改 css 代码，有一定弊端，可以通过修改 HTML 元素来实现，删除 span 标签之间的回车</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span>
	<span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>World<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span></code></pre></td></tr></table></figure><p><img src="/content/images/2016/09/8.png" alt=""></p><p>如果你决定这样会导致代码可读性，可以通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="comment">//拓展到下一行</span>
&lt;body&gt;
	<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>
	&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>World<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>
<span class="comment">// or 注释</span>
&lt;body&gt;
	<span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><span class="xml"><span class="comment">&lt;!--
	--&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>World<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></code></pre></td></tr></table></figure><p>哈哈，总之，把该死的 <code>font-size:0</code> 忘记。</p><p>原理我想也心知肚明了，肯定是回车在搞鬼，它就像 p 标签一样。</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>在搭自己博客和主页的时候，碰到了浏览器缓存的问题，大致描述一下：</p><p>有时候觉得网站的某些样式不是很漂亮，或者字体大小不合适，或者某个背景颜色有点深（其实我的审美已经严重扭曲），一天一天的积累，把它慢慢的修改，久而久之，一些 CSS、JS 文件变化很大。</p><p>但是，浏览器都有缓存，之前打开的网页浏览器会保存缓存一定的时间，当再次访问的时候，如果还是同名的文件，浏览器会从本地缓存中找，如果找到且缓存的有效期没有到，就不用向服务器再次申请，比如，下面是我博客某个 CSS 资源的响应头：</p><p><img src="/content/images/2016/09/9.png" alt=""></p><p>其中标红框的就是服务器向用户的浏览器发送的缓存要求，大致就是说这个 CSS 文件你可以放到缓存中(public 只有在刷新的时候才会向服务器请求)，缓存的有效期是一年(356 <em>24 </em>60 * 60 = 31536000，单位是秒)。</p><p>看着都要哭了，也就是说，如果我修改了某个 CSS 文件，别人不刷新网页，是无法获得新的 CSS 资源（这个 max-age 是右 Ghost 的默认设置造成的）。</p><p>解决办法也是有的，那就是资源重命名，给浏览器造成一种假象，就是它要访问的资源不在缓存：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><code class="html"><span class="tag">&lt;<span class="name">head</span>&gt;</span>
	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/style.css"</span>&gt;</span>
	//把原来的资源改成另一个名字
	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"/style-0916.css"</span>&gt;</span>
<span class="tag">&lt;/<span class="name">head</span>&gt;</span></code></pre></td></tr></table></figure><p>现在好多的构建构建 gulp、webpack 都带重命名插件，使用起来也很方便。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/09/16/8%E6%9C%88%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JS 进阶之路 : 深入理解函数的概念</title>
      <link>http://yuren.space/blog/2016/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <guid>http://yuren.space/blog/2016/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <pubDate>Sun, 11 Sep 2016 09:35:58 GMT</pubDate>
      <description>
      
        JS 进阶 深入 理解 函数 概念
      
      </description>
      
      <content:encoded><![CDATA[<p>之前一直觉得自己对 JavaScript 这门语言掌握的还可以，记得当初学这门语言的时候，也都是按照 Java 的思维去学的，以至于很多概念都没有弄明白。</p><a id="more"></a><p>最近在 <a href="https://www.codewars.com" target="_blank" rel="external">codewars</a> 做练习的时候，才发现，原理的东西，一个都没有搞懂，JS 最精华的函数、闭包都是在以自己的思维去揣测，而非真正的理解。之前看 《JavaScript 权威指南》，书中内容虽然说的很细，却没有说懂。</p><p>最近一周看了一下网上比较火的《JavaScript 忍者秘籍》，闭包、函数说的很清楚，不由感叹，真是一本进阶的好书呀。这本书帮我解决了很多困惑的问题，让我对 JS 这门语言有了深刻的认识，这一周，让我体会到了读书的愉悦，感觉学到了非常多的知识。</p><p>看书的时候，记了笔记，而我又想写点什么来记录下自己的成果，决定分几篇小博客来记录一下我的心得体会。</p><h3 id="JavaScript-中的函数"><a href="#JavaScript-中的函数" class="headerlink" title="JavaScript 中的函数"></a>JavaScript 中的函数</h3><p>JavaScript 中的函数形式多样，可以定义，也可以内联，这样子定义函数才有意思。</p><p>Java 是非函数式语言，而 JavaScript 中的函数式特性允许我们创建一个独立的实体函数，并将这个实体作为参数一样使用（这跟Python很像，不知道是谁先创的）。当别的函数或实体接收这个函数参数之后，就可以当作函数拿来用。</p><p>我在使用函数的时候，总结出这么一个特点，就是为什么有时候用 function()，而有时候用 function，（区别在于有没有括号）比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;
    <span class="comment">//do something</span>
    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);
&#125;
<span class="comment">//作为函数直接调用</span>
sayHello()  <span class="comment">// 'hello'</span>
<span class="comment">//作为函数参数传递</span>
<span class="keyword">var</span> say = sayHello; 
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> say === <span class="string">'function'</span>) <span class="comment">//true</span>
say() <span class="comment">// 'hello'</span></code></pre></td></tr></table></figure><p>如果一个函数参数后面加了()，它就会立即执行，比如 <code>sayHello()</code>，就会跑到函数所在的位置把函数跑一边，这跟其他语言的函数调用一样；不加()会把函数作为参数传递。<code>var say = sayHello</code>，这个时候，say 变量也是函数变量，可通过 <code>say()</code>调用。</p><h3 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h3><p>关于函数内变量的作用域，必须要注意，否则变量会 undefined 的：</p><ol><li>函数内部的变量的作用域开始与声明的地方，结束于函数的结尾，与代码嵌套无关；</li><li>命名函数的作用域是指申明该函数所在区域的整个函数范围，与代码嵌套无关；</li><li>整个 window 是一个包含所有代码的超大型函数。</li></ol><p>第一个很好理解，在没有申明之前，变量无法使用，结束后也无法使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">theTest</span>(<span class="params"></span>)</span>&#123;
    <span class="built_in">console</span>.log(test); <span class="comment">//undefined</span>
    <span class="keyword">var</span> test = <span class="string">'hello'</span>;
    <span class="built_in">console</span>.log(test); <span class="comment">// 'hello'</span>
&#125;
theTest();
<span class="built_in">console</span>.log(test); <span class="comment">//error,</span></code></pre></td></tr></table></figure><p>第二个的意思大致是函数定义不像变量，不用考虑顺序，但要考虑作用域，及申明函数的整个区域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="javascript">sayHello(); <span class="comment">// 'hello'</span>
<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;
    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);
    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;
    	<span class="built_in">console</span>.log(<span class="string">'inner'</span>);
    &#125;
&#125;
inner(); <span class="comment">// error not defined</span></code></pre></td></tr></table></figure><p>关于第三个，window 就是一个全局变量，可以通过 this 来调用。this 算是 JS 中用的最妙的，this 是动态的，我们写了一个函数，而调用这个函数的主体是可变的，这和 Java 的继承很像。</p><p>关于作用域，有一点需要注意，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(text); <span class="comment">// undefined</span>
	<span class="keyword">var</span> text = <span class="string">'Hello'</span>;
	<span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(text);
	&#125;
	sayHello(); <span class="comment">// 'hello'</span>
&#125;
outer();
<span class="keyword">this</span>.sayHello() <span class="comment">// 'hello'</span></code></pre></td></tr></table></figure><p>结果居然是 <code>undefined =&gt; Hello =&gt; Hello</code>，undefined 很好理解，<code>text</code>定义之前是无法调用的，但是在函数外面通过 <code>this.sayHello()</code>却可以访问已经失效的变量，这说明函数（这实际上是一个闭包，之后的博客会提到）一旦建立之后，其内部的变量会被保存，以便访问的时候不会出错。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>面试官往往喜欢问一下关于函数中 this 的指代，实际上函数在调用的过程中会默认传递两个隐式参数，分别是 arguments 和 this（这两个都是带有传奇色彩的参数）。arguments 是一个伪数组，而this 的指代大概有下面几种：</p><ol><li>作为函数调用，this 指代是 window；</li><li>对象的方法，this 指代改对象；</li><li>new 构造器，经过一系列转换，this 最终的结果会赋值给创建 new 的那个变量，有个先后顺序，下面会有例子；</li><li>call 、 apply 、bind 等函数通过参数指定 this 的值。</li></ol><p>下面我自己写了一个例子，这是我在调试时候遇到的，可以总结第一条和第四条：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;
	<span class="keyword">var</span> fn = <span class="keyword">this</span>; <span class="comment">//通过 call 方法 this 指代 myObj</span>
	<span class="built_in">console</span>.log(fn.name); <span class="comment">// 'song'</span>
	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">note</span>)</span>&#123;
		<span class="built_in">console</span>.log(note); <span class="comment">// 'this is note'</span>
		<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span>
		<span class="built_in">console</span>.log(fn === myObj); <span class="comment">// true</span>
	&#125;
&#125;
<span class="keyword">var</span> myObj = &#123;
	<span class="attr">name</span> : <span class="string">'song'</span>
&#125;;
test.call(myObj)(<span class="string">'this is note'</span>);</code></pre></td></tr></table></figure><p>结果很明显，代码的执行顺序大致是：<code>myObj</code> =&gt; <code>test.call(myObj)</code> =&gt; <code>test()</code>(this是 call 来的，符合第四个规则) =&gt; <code>myObj(&quot;this is note&quot;)</code> =&gt; <code>function(note)</code>(this符合第一个规则)。</p><p>看下面分析，自己可以亲手调试一下：</p><p><img src="/content/images/2016/09/test2.png" alt=""></p><p>第二条对象的方法指代对象，其实对象的这个方法是个函数，举个例子就好理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="javascript"><span class="comment">// 建立一个对象</span>
<span class="keyword">var</span> myObj=&#123;
	<span class="attr">name</span> : <span class="string">'song'</span>,
	<span class="attr">func</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 'song'</span>
		<span class="built_in">console</span>.log(<span class="keyword">this</span> === myObj); <span class="comment">// true</span>
	&#125;,
&#125; 
myObj.func();</code></pre></td></tr></table></figure><p>对第三条的解释，先看下面的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="keyword">this</span> === myObj) <span class="comment">// false</span>
	<span class="keyword">this</span>.name = <span class="string">'song'</span>;
&#125;
<span class="keyword">var</span> myObj = <span class="keyword">new</span> test();
<span class="built_in">console</span>.log(myObj.name); <span class="comment">// 'song'</span></code></pre></td></tr></table></figure><p>之所以 <code>this === myObj</code>会为 false，是因为new test()方法中的 this 并不是指向 myObj，它先是自己建立一个对象，把 this 指向自己，最终函数结束时候把 this 传递给myObj对象，<code>console.log(myObj.name)</code>才会有结果。</p><p><img src="/content/images/2016/09/test3.png" alt=""></p><p>并不是我们所想的 this 指向 myObj。总之，这里的 this 不是指向 window。</p><h3 id="cache-缓存，函数对象"><a href="#cache-缓存，函数对象" class="headerlink" title="cache 缓存，函数对象"></a>cache 缓存，函数对象</h3><p>如果说明函数是参数，可以传递，已经让人很兴奋，但事实上，函数还是对象，它是一个真实存在的变量。</p><p>下面是一个递归的 fibonacci 数列：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><code class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> </span>&#123;
    <span class="keyword">if</span>(n==<span class="number">0</span> || n == <span class="number">1</span>)
        <span class="keyword">return</span> n;
    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);
&#125;</code></pre></td></tr></table></figure><p>（不讨论迭代，只考虑递归）我们知道递归会占用栈资源，当调用 1000000 次，可能会造成栈溢出。下面是一个采用函数内存的方法实现的 fibonacci 数列：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><code class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span></span>&#123;
	<span class="keyword">if</span>(!fibonacci.cache) <span class="comment">//在这里先判断fibonacci.cache是否存在</span>
		fibonacci.cache=[<span class="number">0</span>,<span class="number">1</span>] <span class="comment">//默认设置 0，1</span>
	<span class="keyword">if</span>(fibonacci.cache[n] != <span class="literal">undefined</span>)
		<span class="keyword">return</span> fibonacci.cache[n];
	<span class="keyword">else</span>&#123;
		<span class="keyword">if</span>(fibonacci.cache[n<span class="number">-1</span>] === <span class="literal">undefined</span>)
			fibonacci.cache[n<span class="number">-1</span>] = fibonacci(n<span class="number">-1</span>);
		<span class="keyword">if</span>(fibonacci.cache[n<span class="number">-2</span>] === <span class="literal">undefined</span>)
			fibonacci.cache[n<span class="number">-2</span>] = fibonacci(n<span class="number">-2</span>);
		<span class="keyword">return</span> fibonacci.cache[n] = fibonacci.cache[n<span class="number">-1</span>] + fibonacci.cache[n<span class="number">-2</span>];
	&#125;
&#125;</code></pre></td></tr></table></figure><p>这种函数即对象的思路很有趣，当我们通过 <code>fibonacci(10)</code>运行 10 次之后，可以看到:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="lasso">fibonacci(<span class="number">10</span>);
console.<span class="keyword">log</span>(fibonacci.<span class="keyword">cache</span>) <span class="comment">//[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span>
console.<span class="keyword">log</span>(fibonacci.name) <span class="comment">// 'fibonacci'</span></code></pre></td></tr></table></figure><p>其实除了给函数对象添加的属性之外，它自己也有自己的属性，比如 name ，arguments ， length 等。</p><p>函数的内容就写到这，共勉。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/09/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>腾讯404公益页面，你中招了吗</title>
      <link>http://yuren.space/blog/2016/09/07/%E8%85%BE%E8%AE%AF404%E5%85%AC%E7%9B%8A%E9%A1%B5%E9%9D%A2/</link>
      <guid>http://yuren.space/blog/2016/09/07/%E8%85%BE%E8%AE%AF404%E5%85%AC%E7%9B%8A%E9%A1%B5%E9%9D%A2/</guid>
      <pubDate>Wed, 07 Sep 2016 00:25:51 GMT</pubDate>
      <description>
      
        腾讯 404 公益 中招
      
      </description>
      
      <content:encoded><![CDATA[<a id="more"></a><p>之前在别人的博客里看到了腾讯的 404 公益页面，感觉很不错，算是腾讯的良心大作啊，被腾讯坑了这么多年（<del>腾讯到底坑了我啥了…</del>）。</p><p>简单介绍一下这个页面，公益404页面是由腾讯公司员工志愿者自主发起的互联网公益活动。<strong>网站只需要在自己的 404 页面中嵌入一段简单的代码</strong>，就能通过互联网来迅速传播失踪儿童信息，从而提高找回失踪儿童的概率。失踪儿童信息来自<a href="http://www.baobeihuijia.com/" target="_blank" rel="external">宝贝回家寻子网</a>。</p><p>至于腾讯 404 页面的介绍并不是本文的主题，我想，凡是看了这个 404 页面的，都会忍不住想要把自己的 404 设置成这种格式的。</p><p>设置很简单，腾讯公益团队提供了一个函数接口，把下面的这个 script 放到 head 标签里：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
//下面是 small 版的，说实话，我现在都还没发现这两个版本有什么区别
<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js?edition=small"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
//可能时间久了，这个 small 被取消了吧</code></pre></td></tr></table></figure><p>这个放到 head 的效果如下，无论你 body 中是什么内容，都会被这个函数的内容给覆盖掉，变成这个：</p><p><img src="/content/images/2016/09/demo.png" alt="示例图1"></p><p>就像箭头指的那样，需要把<code>返回腾讯网</code>改成自己的，比如返回主页啥的，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://www.qq.com/404/search_children.js"</span>
 <span class="attr">homepagename</span>=<span class="string">"返回渔人的主页"</span> <span class="attr">homepageurl</span>=<span class="string">"/"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre></td></tr></table></figure><h3 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h3><p>把上面这段话加到我自己的 404 页面中，发现效果是实现了，但是<code>返回主页</code>一直都有问题，并不是如我所想的<code>返回渔人的主页</code>，而仍然是<code>返回腾讯网</code>，决定<strong>一探究竟</strong>。</p><p><code>http://www.qq.com/404/search_children.js</code> 这个返回的是：</p><p><img src="/content/images/2016/09/demo2.png" alt=""></p><p>第一个 url <code>http://qzone.qq.com/gy/404/data.js</code>，返回的是一个 json 数据，自己可以在浏览器里输入试一下，分析了一下，大概是腾讯员工从宝贝回家网整理来的信息，json 格式。第二个 url <code>http://qzone.qq.com/gy/404/page.js</code> 是处理函数，不是很长，先找到属性 homepagename 和 homepageurl 的位置，从第 31 行开始，50 行结束：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><code class="php"><span class="keyword">var</span> homePageUrl, homePageName;
<span class="comment">//获取所有 &lt;script&gt; 标签</span>
<span class="keyword">var</span> scs = document.getElementsByTagName(<span class="string">"script"</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; scs.length; i++)
	<span class="keyword">if</span> (scs[i].src.indexOf(<span class="string">"/404/search_children.js"</span>) &gt; <span class="number">-1</span>) &#123;
		<span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageUrl"</span>)) homePageUrl = scs[i].getAttribute(<span class="string">"homePageUrl"</span>);
		<span class="keyword">if</span> (scs[i].getAttribute(<span class="string">"homePageName"</span>)) homePageName = scs[i].getAttribute(<span class="string">"homePageName"</span>);
		<span class="keyword">break</span>
	&#125;
<span class="comment">//把标签成功匹配的值传给默认参数</span>
$scope.rettext = homePageName;
$scope.retlink = homePageUrl;
<span class="comment">//实际上函数就应该可以结束了，下面的这段话真的不懂是什么意思</span>
<span class="keyword">if</span> (location.href.indexOf(<span class="string">"fm.qq.com"</span>) &gt; <span class="number">-1</span> || location.href.indexOf(<span class="string">"fm.qzone.qq.com"</span>) &gt; <span class="number">-1</span>) &#123;
	$scope.rettext = <span class="string">"返回企鹅FM"</span>;
	$scope.retlink = <span class="string">"http://fm.qq.com"</span>
&#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.href.indexOf(<span class="string">"qzone.qq.com"</span>) &gt; <span class="number">-1</span>) &#123;
	$scope.rettext = <span class="string">"返回我的空间"</span>;
	$scope.retlink = <span class="string">"http://qzone.qq.com"</span>
&#125; <span class="keyword">else</span> &#123;
	$scope.rettext = <span class="string">"返回腾讯网"</span>;
	$scope.retlink = <span class="string">"http://www.qq.com"</span>
&#125;
<span class="comment">//这样一来，rettext的值又变成 返回腾讯网 了...</span></code></pre></td></tr></table></figure><p><strong>实际上这两个处理逻辑可以换一下</strong>，先通过 href 判断，在查找 homePageUrl homePageName，如果有，就把值换了，这样子的逻辑才合理。<strong>否则</strong>，上面这段代码的处理结果，返回值都是一样的，就是跳到腾讯网主页，哈哈，这个锅腾讯你要背呀。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>通过研究，我发现最终替换 body 内容的是最后的那个闭包函数，所以就把闭包函数作为内联的形式添加到 404 页面的最后，并修改其中：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="mipsasm">$<span class="keyword">scope.rettext </span>= <span class="string">"返回渔人的主页"</span><span class="comment">;</span>
$<span class="keyword">scope.retlink </span>= <span class="string">"/"</span></code></pre></td></tr></table></figure><p><img src="/content/images/2016/09/demo3.png" alt=""></p><p>记住，一定要把这个函数放到<code>search_children.js</code>后面，否则起不到覆盖的效果。</p><p>404页面已经放到 <a href="https://github.com/songjinzhong/404html" target="_blank" rel="external">GitHub </a>上了，无论腾讯页面的这个 bug 是否存心，但是腾讯的这个公益页面还是很赞的，希望能一直走下去，共勉！</p><p><img src="/content/images/2016/09/demo4.png" alt=""></p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/09/07/%E8%85%BE%E8%AE%AF404%E5%85%AC%E7%9B%8A%E9%A1%B5%E9%9D%A2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Windows下用 Python + ImageMagick 批量处理图片</title>
      <link>http://yuren.space/blog/2016/08/27/PythonImageMagick%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/</link>
      <guid>http://yuren.space/blog/2016/08/27/PythonImageMagick%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/</guid>
      <pubDate>Sat, 27 Aug 2016 09:33:31 GMT</pubDate>
      <description>
      
        Windows Python ImageMagick 处理 图片
      
      </description>
      
      <content:encoded><![CDATA[<p>这周研究漏洞时，看了一下关于 ImageMagick 的漏洞，它是远程代码执行漏洞，远程攻击者利用漏洞通过上传恶意构造的图像文件，可在目标服务器执行任意代码，进而获得网站服务器的控制权。</p><a id="more"></a><p>当然，漏洞不是今天讨论的重点，ImageMagick 作为一个开源的图像处理软件，受到广大前端爱好者的喜爱，肯定有其原因的。我在之前只用过 PS 处理图片，根本就没听过 ImageMagick （<del>害羞</del>），研究的时候发现它小巧轻便，还能支持各种脚本（ C++、Python、Java等）批量处理图片，霸气度让觉得能甩 PS 两条街，对于程序员来说，它就是<strong>命令行上的 PhotoShop</strong>。</p><p>它的功能完全不逊 PS，支持和处理超过 90 种图片格式，功能包括格式转换、、变换、透明度、附加、装饰、特效、文本及评论、图像识别、综合、蒙太奇、电影支持、图像计算器、离散傅立叶变换、加密或解密图片、虚拟像素支持、大图像支持、执行、异构分布式处理…</p><p>关看到这些功能，估计你就眼花缭乱了吧！</p><p>今天就来研究一下它是如何用 Python 对图片批量处理的。</p><h3 id="关于安装"><a href="#关于安装" class="headerlink" title="关于安装"></a>关于安装</h3><p>我是在 windows 下安装的，它对 Linux 的支持更好，相对来说，Windows 下安装比较困难，要用 C 编译执行，但是由于官网推出了 .exe 的 Windows 安装文件之后，一切都变得很简单。</p><p><a href="http://www.imagemagick.org/script/binary-releases.php#windows" target="_blank" rel="external">Windows 版本下载</a></p><p><del>是的，你没有看错，这个强大的软件只有 23MB。</del></p><p>在这里不建议下载最新版的，因为后面 Python 写脚本的时候，<code>最新版的暂时还支持不了 Wand 库</code>，可以从下面这个链接下载 6.9.5 ，</p><p><a href="http://www.imagemagick.org/download/binaries/" target="_blank" rel="external">其他 Windows 版本下载</a></p><p><strong>特别注意</strong></p><p>无论你的系统是 64 位还是32 位，一定要看一下你的 Python 是多少位的，下载和 Python 相同位数的版本。比如，我的 Python 是 32 位的，我下载的版本是<code>ImageMagick-6.9.5-7-Q16-x86</code>，不然在后面用 Python 调用 ImageMagick 库的时候，会提示找不到路径的。</p><p>比如下面这个错误 <code>MagickWand shared library not found</code>：</p><p><img src="/content/images/2016/08/error.png" alt=""></p><p>安装，就直接下一步、下一步，注意下图：</p><p><img src="/content/images/2016/08/zhuyi.png" alt=""></p><p>把路径添加到环境变量里，同时要安装 libraries for C and C++。</p><h3 id="第一个-Hello-World"><a href="#第一个-Hello-World" class="headerlink" title="第一个 Hello World"></a>第一个 Hello World</h3><p>安装完成，需要测试一下，到安装目录下面，把 <code>convert.exe</code>改成<code>im_convert.exe</code>，因为<code>convert</code>这个命令和系统命令重复了…</p><p>打开命令行，运行：<code>im_convert nanjing.jpg -gravity southeast -fill white -pointsize 16 -draw &quot;text 5,5 &#39;Hello World&#39;&quot; nanjing_hw.jpg</code>，<strong>如果报错，说明环境变量没有配置好</strong>。</p><p>上面的命令就是执行把 nanjing.jpg 在距右下角（5px，5px）处打上字体白色 Hello World 水印，效果如下：</p><p><img src="/content/images/2016/08/test2.png" alt=""></p><h3 id="强如-Python-脚本"><a href="#强如-Python-脚本" class="headerlink" title="强如 Python 脚本"></a>强如 Python 脚本</h3><p>好啦，开始步入主题，用 Python 配合 ImageMagick 批量处理图。</p><p><strong>安装 Python 的支持库</strong></p><p><a href="http://www.imagemagick.org/script/api.php#python" target="_blank" rel="external">从官方的文档来看</a>，Python 支持 3 个库，分别是 Wand、PythonMagick、PythonMagickWand：</p><p><img src="/content/images/2016/08/python.png" alt=""></p><p>这里我安装的是 <a href="http://docs.wand-py.org/en/0.4.3/" target="_blank" rel="external">Wand</a>， 直接<code>pip install Wand</code>，当然也可以从 GitHub 上 <code>git clone git://github.com/dahlia/wand.git</code>。</p><p>安装好之后，用 <code>import wand</code>测试一下，不保错说明安装成功，</p><p>写了一个小测试：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="python"><span class="keyword">from</span> wand.image <span class="keyword">import</span> Image
<span class="keyword">from</span> wand.display <span class="keyword">import</span> display

<span class="keyword">with</span> Image(filename=<span class="string">'nanjing.jpg'</span>) <span class="keyword">as</span> img:
    print(img.size)
    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>:
        <span class="keyword">with</span> img.clone() <span class="keyword">as</span> i:  <span class="comment"># 克隆图片</span>
            i.resize(int(i.width * r * <span class="number">0.25</span>), int(i.height * r * <span class="number">0.25</span>))
            i.rotate(<span class="number">90</span> * r)
            i.save(filename=<span class="string">'nanjing-&#123;0&#125;.jpg'</span>.format(r))  <span class="comment"># 保存图片</span></code></pre></td></tr></table></figure><p></p><p><img src="/content/images/2016/08/result.png" alt=""></p><p>上面用到了 <code>resize</code>：重新设置图片大小，<code>rotate</code>：图片旋转，<code>save</code>：保存图片。</p><p>如果报出了<code>MagickWand shared library not found</code>的错误，说明你的 Python 没有发现 ImageMagick 提供的接口，可能有以下原因：</p><ol><li>环境变量没配置好</li><li>你的 Python 是32位，你下载的 ImageMagick 是64 位</li><li>Wand 更新较慢，建议用 ImageMagick 稳定版而不是最新版（6.9.5是可用的）</li></ol><p>具体的错误还需要自己 Google，这只是我碰到的。</p><p>ImageMagick 的功能不止如此，这里只是列出了如何简单的使用，毕竟我才接触了两天，深入学习还是要花一定时间的，共勉！</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/27/PythonImageMagick%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>每天一道前端面试题（定期更新）</title>
      <link>http://yuren.space/blog/2016/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</link>
      <guid>http://yuren.space/blog/2016/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</guid>
      <pubDate>Sun, 14 Aug 2016 03:50:43 GMT</pubDate>
      <description>
      
        前端 面试题
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>马上快毕业了(<del>实际上还有一年半</del>)，我本人倾向于前端的工作，想要加深对前端的理解，写了这篇博客，准备每天更新一道前端的面试题(看看能坚持多久吧)。</p><a id="more"></a><p>资料来源于网络，定期补充，<strong>临时抱佛脚</strong>的小伙伴可以直接浏览原帖：</p><ul><li><a href="https://github.com/songjinzhong/Front-end-Interview-questions" target="_blank" rel="external">Front-end-Interview-questions</a></li><li><a href="https://github.com/songjinzhong/front-end-questions" target="_blank" rel="external">front-end-questions</a></li><li><a href="https://github.com/heicx/FE-Article/blob/master/FE-Interview.md" target="_blank" rel="external">FE-Interview</a></li></ul><p>对于一些我整理的解答，来自于以下参考：</p><ul><li><a href="http://www.w3school.com.cn/" target="_blank" rel="external">w3school</a></li></ul><p><strong>一些开放性的试题</strong></p><ul><li>自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。</li><li>项目介绍</li><li>如何看待前端开发？</li><li>平时是如何学习前端开发的？</li><li>未来三年的规划是怎样的？</li></ul><p><strong>面试有几点需注意：(来源寒冬winter 老师，github:@wintercn)</strong></p><ol><li>面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。</li><li>题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。</li><li>细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。</li><li>回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。</li><li>资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。</li></ol><p><strong>2016-08-14</strong></p><p><strong>Q : position 的值, relative 和 absolute 分别是相对于谁进行定位的？</strong></p><ul><li><code>absolute</code> :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</li><li><code>fixed</code> （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定</li><li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位</li><li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li><li><code>inherit</code> 子随父，常见的 CSS 值</li></ul><p><strong>2016-08-15</strong></p><p><strong>Q : 如何解决跨域问题</strong></p><p>先搞懂一个问题，什么是跨域？广义的域是指域名，比如baidu.com 和 google.com，跨域访问，简单来说就是 A 网站的 javascript 代码试图访问 B 网站，包括提交内容和获取内容。</p><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。对于跨域的总结，可以参考这篇文章 <a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a></p><p><strong>JSONP：</strong></p><p>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入。</p><p>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p><p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p><p><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把JSON填充到一个盒子里</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><code class="js">&lt;script&gt;
    <span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;
        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);
        oScript.type = <span class="string">'text/javascript'</span>;
        oScript.src = sUrl;
        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);
    &#125;
    createJs(<span class="string">'jsonp.js'</span>);
    box(&#123;
       <span class="string">'name'</span>: <span class="string">'test'</span>
    &#125;);
    <span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;
        alert(json.name);
    &#125;
&lt;<span class="regexp">/script&gt;</span></code></pre></td></tr></table></figure><p><strong>CORS</strong></p><p>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问。</p><p><strong>通过修改document.domain来跨子域</strong></p><p>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域</p><p>主域相同的使用<code>document.domain</code></p><p><strong>使用window.name来进行跨域</strong></p><p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</p><p><strong>使用HTML5中新引进的<code>window.postMessage</code>方法来跨域传送数据</strong></p><p>还有flash、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p><p><strong>2016-08-16</strong></p><p><strong>Q : XML和JSON的区别？</strong></p><ol><li>数据体积方面<br>JSON相对于XML来讲，数据的体积小，传递的速度更快些。</li><li>数据交互方面<br>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</li><li>数据描述方面<br>JSON对数据的描述性比XML较差。</li><li>传输速度方面<br>JSON的速度要远远快于XML。</li></ol><p><strong>2016-08-17</strong></p><p><strong>Q : 说说TCP传输的三次握手四次挥手策略</strong></p><p>为了准确无误地把数据送达目标处，<code>TCP</code>协议采用了三次握手策略。用TCP协议把数据包送出去后，<code>TCP</code>不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：<code>SYN</code>和<code>ACK</code>。</p><p>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。<br>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p><p><strong>断开一个TCP连接则需要“四次握手”：</strong></p><ul><li>第一次挥手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li><li>第二次挥手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</li><li>第三次挥手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>第四次挥手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul><p><strong>2016-08-18</strong></p><p><strong>Q : TCP和UDP的区别</strong></p><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p><p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p><p><strong>2016-08-19</strong></p><p><strong>Q : onmousemove 和 onmouseover 的区别?</strong></p><ul><li>时间上：onmousemove事件触发后，再触发onmouseover事件。</li><li>按钮上：不区分鼠标按钮。</li><li>动作上：onmouseover只在刚进入区域时触发，onmousemove除了刚进入区域触发外，在区域内移动鼠标，也会触发</li></ul><p>关于这两个函数：</p><p><code>onmousemove</code> 事件会在鼠标指针移动时发生。<strong>每当用户把鼠标移动一个像素，就会发生一个 mousemove 事件。</strong>这会耗费系统资源去处理所有这些 mousemove 事件。因此请审慎地使用该事件。</p><p><code>onmouseover</code> 当鼠标指针移动到图像上时执行一段 JavaScript。</p><p><strong>2016-08-20</strong></p><p><strong>Q : 说说你对闭包的理解</strong></p><p>推荐看一下这篇博客，说的很不错<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">学习Javascript闭包（Closure）</a>。</p><p><strong>闭包就是能够读取其他函数内部变量的函数。</strong>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。闭包就是将函数内部和函数外部连接起来的一座桥梁。</p><p><strong>使用闭包需要注意：</strong>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p><strong>2016-08-22</strong></p><p><strong>Q : 创建ajax过程</strong></p><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li><li>设置响应HTTP请求状态变化的函数.</li><li>发送HTTP请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><p><strong>2016-08-23</strong></p><p><strong>Q : Doctype作用？标准模式与兼容模式各有什么区别?</strong></p><ol><li>&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于<html>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</html></li><li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</li></ol><p><strong>2016-08-24</strong></p><p><strong>Q : 渐进增强和优雅降级</strong></p><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p><p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p><p><strong>2016-08-25</strong></p><p><strong>Q : sql注入原理</strong></p><p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。总的来说有以下几点：</p><ol><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li><li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</li></ol><p><strong>2016-08-26</strong></p><p><strong>Q : XSS原理及防范</strong></p><p>Xss( cross-site scripting )攻击指的是攻击者往Web页面里插入恶意 <code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p><p><strong>XSS防范方法</strong></p><p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p><p>首先，避免直接在<code>cookie</code> 中泄露用户隐私，例如email、密码等等。</p><p>其次，通过使<code>cookie</code> 和系统<code>ip</code> 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的<code>cookie</code> 没有实际价值，不可能拿来重放。</p><p>尽量采用<code>POST</code> 而非<code>GET</code> 提交表单</p><p><strong>2016-08-27</strong></p><p><strong>Q : Web worker主线程</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="js"><span class="number">1.</span>通过 worker = <span class="keyword">new</span> Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。
<span class="number">2.</span>通过worker.postMessage( data ) 方法来向worker发送数据。
<span class="number">3.</span>绑定worker.onmessage方法来接收worker发送过来的数据。
<span class="number">4.</span>可以使用 worker.terminate() 来终止一个worker的执行。</code></pre></td></tr></table></figure><p><code>WebSocket</code>是<code>Web</code>应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个<code>HTML5</code>协议，<code>WebSocket</code>的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p><p><strong>2016-08-28</strong></p><p><strong>Q : HTTP 和 HTTPS</strong></p><p><code>HTTP</code>协议通常承载于TCP协议之上，有时也承载于<code>TLS</code>或<code>SSL</code>协议层之上，这个时候，就成了我们常说的HTTPS。</p><p>默认HTTP的端口号为80，<code>HTTPS</code>的端口号为443。</p><p><strong>2016-08-29</strong></p><p><strong>Q : HTTP 和 HTTPS</strong></p><p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<code>HTTPS</code>，密钥在你和终点站才有。<code>https</code>之所以比<code>http</code>安全，是因为他利用<code>ssl/tls</code>协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p><p><strong>2016-08-30</strong></p><p><strong>Q : Javascript垃圾回收方法</strong></p><p><strong>标记清除（mark and sweep）</strong></p><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p><p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p><p><strong>引用计数(reference counting)</strong></p><p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p><p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及<code>BOM</code>及DOM就会出现循环引用问题。</p><p><strong>2016-08-31</strong></p><p><strong>Q : 你觉得前端工程的价值体现在哪</strong></p><ol><li>为简化用户使用提供技术支持（交互部分）</li><li>为多个浏览器兼容性提供支持</li><li>为提高用户浏览速度（浏览器性能）提供支持</li><li>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</li><li>为展示数据提供支持（数据接口）</li></ol><p><strong>2016-09-01</strong></p><p><strong>Q : display:none和visibility:hidden的区别？</strong></p><p><code>display:none</code>隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，<br>就当他从来不存在。</p><p><code>visibility:hidden</code>隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p><p><strong>2016-09-05</strong></p><p><strong>Q : CSS中 link 和@import 的区别是？</strong></p><ol><li>link属于HTML标签，而@import是CSS提供的;</li><li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li><li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li><li>link方式的样式的权重 高于@import的权重.</li></ol><p><strong>2016-09-06</strong></p><p><strong>Q : 介绍一下box-sizing属性？</strong></p><p><code>box-sizing</code>属性主要用来控制元素的盒模型的解析模式。默认值是<code>content-box</code>。</p><ul><li><code>content-box</code>：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高</li><li><code>border-box</code>：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content</li></ul><p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p><p><strong>2016-09-07</strong></p><p><strong>Q : 介绍一下box-sizing属性？</strong></p><p><strong>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</strong></p><ol><li>id选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器（a: hover, li:nth-child）</li></ol><p>继承样式</p><ul><li>可继承的样式： font-size font-family color, text-indent;</li><li>不可继承的样式：border padding margin width height;</li><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li></ul><blockquote><p>优先级为:</p></blockquote><pre><code>!important &gt;  id &gt; class &gt; tag  

important 比 内联优先级高,但内联比 id 要高
</code></pre><blockquote><p>CSS3新增伪类举例：</p></blockquote><pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
</code></pre><p><strong>2016-09-09</strong></p><p><strong>Q : CSS3有哪些新特性？</strong></p><p>CSS3实现圆角（border-radius），阴影（box-shadow），<br>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜<br>增加了更多的CSS选择器 多背景 rgba<br>在CSS3中唯一引入的伪元素是::selection.<br>媒体查询，多栏布局<br>border-image</p><p><strong>2016-09-12</strong></p><p><strong>Q : 说说你对语义化的理解？</strong></p><ol><li>去掉或者丢失样式的时候能够让页面呈现出清晰的结构</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ol>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的建站路5：增加进度条和统计汉字个数</title>
      <link>http://yuren.space/blog/2016/08/13/%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%B1%89%E5%AD%97/</link>
      <guid>http://yuren.space/blog/2016/08/13/%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%B1%89%E5%AD%97/</guid>
      <pubDate>Sat, 13 Aug 2016 08:50:10 GMT</pubDate>
      <description>
      
        建站 进度条 统计 汉字
      
      </description>
      
      <content:encoded><![CDATA[<a id="more"></a><p>先看一下效果吧，这是我博客中的例子：</p><p><strong>图1</strong></p><p><img src="/content/images/2016/08/jindutiao1.png" alt=""></p><p><strong>图2</strong></p><p><img src="/content/images/2016/08/jindutiao2.png" alt=""></p><p>先是统计本文的字数，估计一个大致阅读时间（阅读时间做法比较粗糙），随着屏幕向下划，阅读进度不断更新，同时进度条也向右滚动。</p><p>这个其实是抄袭来的，感觉很炫酷，就拿过来用了。那个博客是个外国人的，我通过网页，把代码一点一点的搬过来，然后稍微修改，加入对中文的支持（也费了很大功夫才完成）。</p><h3 id="在博客中添加"><a href="#在博客中添加" class="headerlink" title="在博客中添加"></a>在博客中添加</h3><p>能用到进度条的也就是在 post.hbs 页面中，即博客的内容页面，理所应当，进度条应该放到这里。它们显示的位置已经被规定死了，在顶端部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><code class="html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"reading-time-indicator js-post-sticky-header"</span>&gt;</span>
	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-reading-time js-post-reading-time"</span>&gt;</span>
		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"percent js-percent-count"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
		<span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"read-progress-indicator single"</span> <span class="attr">max</span>=<span class="string">"12982"</span>&gt;</span>
			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress-container"</span>&gt;</span>
				<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"progress-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
		<span class="tag">&lt;/<span class="name">progress</span>&gt;</span>
		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"read-estimation"</span>&gt;</span>
			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"reading-time-blog-logo"</span>&gt;</span>
				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"blog-logo"</span> <span class="attr">href</span>=<span class="string">"javascript:history.go(-1)"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa fa-chevron-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"read-estimation-content"</span>&gt;</span>
				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"estimated-time"</span>&gt;</span>
					<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"js-word-count"</span>&gt;</span>3245<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 字 --- 耗时<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"eta"</span>&gt;</span>5 分钟<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.
				<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
			<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre></td></tr></table></figure><p>进度条有两个功能，先来介绍一下进度条吧。</p><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>通过 html 标签可以看到，进度条用的是一个叫做 <strong>progess</strong> 的 HTML 5标签，这个标签支持 max 和 value 属性，分别定义完成时的值和当前已经完成的值（其实我觉得还不如用百分百来的直接）。<a href="http://www.w3school.com.cn/html5/html5_progress.asp" target="_blank" rel="external">W3School对 Progess 的介绍</a></p><p><strong>既然是一个百分百，这个百分百从何而来？</strong></p><p>max 的内容好办，肯定是文章的长度。文章内容最外层是包裹在 html 的 article 标签里，真正的内容是在 <code>class=post-content</code>里，令 <code>max=$(&#39;.post-content&#39;).height()</code>。</p><p>value 是根据当前 window 的滑动条的长度决定的，<code>value=$(window).scrollTop()</code><strong>有一个问题</strong>，当前的滑动条包括 header 部分，长度大概有 400px ，但是不固定，带来的结果导致我们浏览的进度条总是比实际值要快，这部分需要剪掉，<code>value=$(window).scrollTop()-$(&#39;header&#39;).height()-240</code>。表达式最后减的 240 是<code>padding-bottom</code> 和 <code>padding-top</code> 的长度。</p><p>函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="javascript"><span class="keyword">var</span> getHeader = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;
	<span class="keyword">return</span> $(<span class="string">'header'</span>).height()+<span class="number">240</span>
&#125;
<span class="keyword">var</span> getMax = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;
	<span class="keyword">return</span> $(<span class="string">'.post-content'</span>).height();
&#125;;
<span class="keyword">var</span> getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;
	<span class="keyword">return</span> $(<span class="built_in">window</span>).scrollTop()-getHeader();
&#125;;</code></pre></td></tr></table></figure><p>当滑动条处于 top 位置或者读完整个文章后，要把进度条隐藏，当进度条刷新时，不断改变当前 value 的值。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><code class="mel">$(document).on(<span class="string">'scroll'</span>, function()&#123;
	<span class="comment">// On scroll only Value attr needs to be calculated</span>
	<span class="keyword">progressBar</span>.attr(&#123; value: getValue() &#125;);
	<span class="keyword">percent</span> = Math.<span class="keyword">floor</span>((getValue() / getMax()) * <span class="number">100</span>) ;
	<span class="keyword">if</span> (<span class="keyword">percent</span> &lt; <span class="number">0</span>) &#123;
		<span class="keyword">percent</span> = <span class="number">0</span>;
		$(<span class="string">'.js-post-sticky-header'</span>).removeClass(<span class="string">'visible'</span>);
	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">percent</span> &gt; <span class="number">100</span>) &#123;
		<span class="keyword">percent</span> = <span class="number">100</span>;
		$(<span class="string">'.js-post-sticky-header'</span>).removeClass(<span class="string">'visible'</span>);
	&#125; <span class="keyword">else</span> &#123;
		$(<span class="string">'.js-post-sticky-header'</span>).addClass(<span class="string">'visible'</span>);
	&#125;
	$(<span class="string">'.js-percent-count'</span>).<span class="keyword">text</span>(<span class="keyword">percent</span> + <span class="string">'%'</span>);
&#125;);
$(<span class="keyword">window</span>).resize(function()&#123;
	<span class="comment">// On resize, both Max/Value attr needs to be calculated</span>
	<span class="keyword">progressBar</span>.attr(&#123; <span class="keyword">max</span>: getMax(), value: getValue() &#125;);
&#125;);</code></pre></td></tr></table></figure><h3 id="设置阅读时间"><a href="#设置阅读时间" class="headerlink" title="设置阅读时间"></a>设置阅读时间</h3><p>先要统计文本的数量，由于原 api 只能支持英文，我加入了中文和数字的统计，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="comment">//通过正则表达式来获得文档的单词，汉字和数字个数</span>
<span class="comment">//text = $('.Post-Content').text();</span>
<span class="keyword">var</span> totalWords=<span class="number">0</span>;
<span class="keyword">var</span> pattern_char = <span class="regexp">/[a-zA-Z]+/g</span>;
<span class="keyword">var</span> pattern_cn = <span class="regexp">/[\u4e00-\u9fa5]/g</span>;
<span class="keyword">var</span> pattern_num = <span class="regexp">/[0-9]+/g</span>
<span class="keyword">var</span> count_char = text.match(pattern_char)?text.match(pattern_char).length:<span class="number">0</span>;
<span class="keyword">var</span> count_cn = text.match(pattern_cn)?text.match(pattern_cn).length:<span class="number">0</span>;
<span class="keyword">var</span> count_num=text.match(pattern_num)?text.match(pattern_num).length:<span class="number">0</span>;
totalWords=count_char+count_cn+count_num;</code></pre></td></tr></table></figure><p>其中，pattern_char 用来匹配英文单词数量，pattern_cn用来统计汉字数量，pattern_num用来统计纯数字的数量，然后把他们相加就是 totalWords 的数量。</p><p>其他的就没什么了，想法都很简单，具体可以参考 <a href="https://github.com/songjinzhong/GhostTheme_sjz" target="_blank" rel="external">Github源码</a>，本文介绍的源码在 assets/js/main.js 和 assets/js/vendor/reading-time.js 两个文件中。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/13/%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%B1%89%E5%AD%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的建站路4：解决 lunr.js 的中文支持问题</title>
      <link>http://yuren.space/blog/2016/08/12/lunrjs%E7%9A%84%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/</link>
      <guid>http://yuren.space/blog/2016/08/12/lunrjs%E7%9A%84%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/</guid>
      <pubDate>Fri, 12 Aug 2016 14:14:36 GMT</pubDate>
      <description>
      
        我的建站路4：解决 lunr.js 的中文支持问题
      
      </description>
      
      <content:encoded><![CDATA[<p>之前已经说过了，还没有为博客添加搜索功能，实际上，这个功能早已经实现了，只是还存在bug，比如对中文的强烈不兼容（实际上只支持汉语拼音，就是你要搜索“问题”，要打“wen ti”，真尴尬）。</p><a id="more"></a><h3 id="安装搜索框"><a href="#安装搜索框" class="headerlink" title="安装搜索框"></a>安装搜索框</h3><p>决定还是把搜索框和菜单栏放到一起，效果也和菜单栏一样，这边呢使用了一个 Github 上开源的基于 Ghost 的搜索插件，名字叫做 GhostHunter，<a href="https://github.com/jamalneufeld/ghostHunter" target="_blank" rel="external">地址在这。</a></p><p>使用方法很简单，在HTML中引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.ghostHunter.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>

<span class="tag">&lt;<span class="name">form</span>&gt;</span>
	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"search-field"</span> /&gt;</span> //id为”search-field“
	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"search"</span>&gt;</span>
<span class="tag">&lt;/<span class="name">form</span>&gt;</span>
<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"results"</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span>
//”results“为输出结果</code></pre></td></tr></table></figure><p>在另外一个 js 文件中用下面的方式调用：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="livescript">$(<span class="string">"<span class="subst">#search-field</span>"</span>).ghostHunter(&#123;
	  results   : <span class="string">"<span class="subst">#results</span>"</span>
&#125;);</code></pre></td></tr></table></figure><p>它还有很多的使用方法，具体可以参考 Github 上的说明。</p><p>这个库是基于 lunr.js ，最大的尴尬是不支持中文，之前在 Github 上看到一个支持中文的 lunr.js ，地址找不到了，这段时间研究了一下 lunr.js，发现了其中的不少奥秘。</p><h3 id="关于lunrjs"><a href="#关于lunrjs" class="headerlink" title="关于lunrjs"></a>关于lunrjs</h3><p>Lunr.js 是一个 JavaScript 搜索引擎，是JS前端框架，可以快速的搜索静态的HTML内容，非常适合单页或者是无数据库的Web网页应用搜索，可以实现简单的全文搜索。</p><p>现在的博客系统都支持 RSS 订阅，是 XML 格式的，lunr.js 刚好可以用在博客系统的搜索上面，是一个独立于博客系统的搜索插件。</p><p>它的优势在于可以减轻服务器的搜索负载，只需从服务器加载 RSS 数据，在本地实现搜索操作。lunr.js 没有外部依赖，只需一个支持的浏览器。<a href="http://lunrjs.com/" target="_blank" rel="external">官网地址</a>。</p><p>在 html 中调用 lunr.js 或 lunr.min.js，然后使用方法如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><code class="qml"><span class="built_in">var</span> index = lunr(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;
	<span class="keyword">this</span>.field(<span class="string">'title'</span>, &#123;<span class="attribute">boost</span>: <span class="number">10</span>&#125;)
	<span class="keyword">this</span>.field(<span class="string">'body'</span>)
	<span class="keyword">this</span>.ref(<span class="string">'id'</span>)
&#125;)

index.add(&#123;
	<span class="attribute">id:</span><span class="string"> 1,
	title</span>: <span class="string">'Foo'</span>,
	<span class="attribute">body</span>: <span class="string">'Foo foo foo!'</span>
&#125;)
index.add(&#123;
	<span class="attribute">id:</span><span class="string"> 2,
	title</span>: <span class="string">'Bar'</span>,
	<span class="attribute">body</span>: <span class="string">'Bar bar bar!'</span>
&#125;)

index.search(<span class="string">'foo'</span>)</code></pre></td></tr></table></figure><p><code>this.field()</code>就是添加索引体，<code>id</code>表示索引 id ，就是我们在搜索的时候返回的 id 。<code>this.field()</code>有一个可选参数，<code>boost</code>的官方解释是 <strong>An optional boost param can be passed to affect how much tokens in this field rank in search results, by default the boost value is 1.</strong>翻译过来就是一个权重值，权重越大，搜索的等级就越高。</p><p>lunr.js 词分析器基于 Martin Porter’s 算法，这个算法具体是怎么分词的，看了半天我也没看懂，自己写了一个例子，通过 chrome 的调试，才算弄懂了，具体见下图：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="stylus">index.add(&#123;
	id: <span class="number">1</span>,
	title: <span class="string">'abc def'</span>,
	<span class="selector-tag">body</span>: <span class="string">'hijk lmnb'</span>
&#125;)
<span class="selector-tag">var</span> result=index.search(<span class="string">"abc"</span>)</code></pre></td></tr></table></figure><p>设置断点，调试，发现其实用于搜索的是个树结构，如下图：</p><p><img src="/content/images/2016/08/lunrjs1.PNG" alt=""></p><p>title 和 body 中共有三个词 abc、def和hijk，首字母开头是a、d、h，再看子节点，</p><p><img src="/content/images/2016/08/lunrjs2.png" alt=""></p><p>会顺着树杈走下去，<code>d-&gt;e-&gt;f</code>，根节点的 <code>ref=1</code>表示搜索结果的 id 为1，tf 是 score，值是通过函数 <code>tokenCount / fieldLength * field.boost</code>得到的，0.5*10=5。score 这个值的属性可以用来排名，比如搜索结果大于一条的时候，排名靠前的往往是值较大的。</p><p>看看<code>hijk</code>的值，为0.5：</p><p><img src="/content/images/2016/08/lunrjs4.png" alt=""></p><p>那么 lunrjs 的搜索应该就是利用树来搜索。</p><p>之前看了一篇 Github 上关于添加中文支持，就是加了下面这句话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><code class="javascript">lunr.trimmer = <span class="function"><span class="keyword">function</span> (<span class="params">token</span>) </span>&#123;
<span class="comment">//check token is chinese then not replace	</span>
	<span class="keyword">if</span>(isChineseChar(token))&#123;
		<span class="keyword">return</span> token;
	&#125;
  <span class="keyword">return</span> token
	.replace(<span class="regexp">/^\W+/</span>, <span class="string">''</span>)
	.replace(<span class="regexp">/\W+$/</span>, <span class="string">''</span>)
&#125;

<span class="function"><span class="keyword">function</span> <span class="title">isChineseChar</span>(<span class="params">str</span>)</span>&#123;     
   <span class="keyword">var</span> reg = <span class="regexp">/[\u4E00-\u9FA5\uF900-\uFA2D]/</span>;  
   <span class="keyword">return</span> reg.test(str);  
&#125;</code></pre></td></tr></table></figure><p>trimmer 是用来对 tokens 进行过滤，把一些非字母替换掉，加入中文的判断，如果是中文，返回。</p><p>这里有一个问题，英文字母是按照空格来区分每一个单词的，而对于中文，一句话说完才会结束，即使加了这句话，要想正常使用，还是不行的。经过测试，会把“今天天气很好”当作一句话来处理。</p><p><strong>解决的办法有两个，加入分词，或者强行加入空格来区分每一个单词。</strong></p><p><strong>先介绍一下分词</strong>，由于博主先前研究生上课的时候，学习过一些大数据分析的算法，其中就有用中文分词算法来实现中文句子的分词，这是另一门艺术，给你推荐一个分词算法 <a href="http://technology.chtsai.org/mmseg/" target="_blank" rel="external">MMSEG</a>，感兴趣的小伙伴可以去研究一下。</p><p>通过单步调试，先把 title 改成“go back home”，调试到 <code>lunr.tokenizer</code>函数的时候：</p><p><img src="/content/images/2016/08/lunrjs5.png" alt=""></p><p><code>return rs</code>已经由字符串变成处理好的数组，英文是根据空格来区分每个字母的，所有当我们把 title 换成“我想家了妈妈，我想回家”，结果如下：</p><p><img src="/content/images/2016/08/lunrjs7.png" alt=""></p><p>这里已经很明显了，由于中文没有分词，返回的数组是按照标点符号和空格来划分的，中文分词算法放到哪里，你也应该知道了：</p><p><img src="/content/images/2016/08/lunrjs8.png" alt=""></p><p>可以使用一个循环，处理数组的每一个元素，重新返回一个把中文分词的新数组。</p><p><strong>后来，我又发现了一种更简单的方法！！</strong></p><p>根本不需要调试把中文分词算法加到 lunr.js 中，如果 <strong>lunr.add</strong> 加入的词已经是中文分词分好的，比如下面例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><code class="less"><span class="comment">//之前的笨方法</span>
<span class="selector-tag">index</span><span class="selector-class">.add</span>(&#123;
	<span class="attribute">id</span>: <span class="number">1</span>,
	<span class="attribute">title</span>: <span class="string">'我想家了妈妈，我想回家'</span>,
	<span class="attribute">body</span>: <span class="string">''</span>
&#125;)
<span class="comment">//在 add 之前先用中文分词处理一下title</span>
<span class="selector-tag">index</span><span class="selector-class">.add</span>(&#123;
	<span class="attribute">id</span>: <span class="number">1</span>,
	<span class="attribute">title</span>: <span class="string">'我 想家 了 妈妈 我 想 回家'</span>,
	<span class="attribute">body</span>: <span class="string">''</span>
&#125;)</code></pre></td></tr></table></figure><p>是我之前太笨了，太年轻！</p><p><strong>介绍一下第二种方法吧</strong>，我正在使用的方法，其实呢，Ghost 博客在 RSS 中加入了 description 用来解释博客，我们可以在索引中将标题手动添加空格，或者一些特殊的标点符号（建议使用空格）。比如本文的 description 是“解决 lunrjs 中文 支持 问题”。</p><p>这样做的优点是，我们还可以加入一些有用的分词，即使分词和文本内容没有关系。例如这篇文章是用 JavaScript 写的，但是通过 JavaScript 是搜索不到的，可以在 description 中加入 JavaScript 这个标签。</p><p>不过，这种方法有个很大的缺点，就是当内容很多或不支持 description 时就不适用了。建议使用分词算法。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/12/lunrjs%E7%9A%84%E4%B8%AD%E6%96%87%E6%94%AF%E6%8C%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的建站路3：为博客增加一些实用功能</title>
      <link>http://yuren.space/blog/2016/08/07/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/</link>
      <guid>http://yuren.space/blog/2016/08/07/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/</guid>
      <pubDate>Sun, 07 Aug 2016 05:13:54 GMT</pubDate>
      <description>
      
        建站 博客 增加 实用 功能
      
      </description>
      
      <content:encoded><![CDATA[<p>现的情况就是，博客已经基本能用了，黑色简约的风格，给人直观的感受就是：低调，大方。这是我觉得这个博客模板很棒的在原因之一。</p><a id="more"></a><p><strong>但是</strong>，<code>abc theme</code> 是一个免费的 Ghost 模板，而它作为一个免费的模板，被挂在一家卖 Ghost 主题的网站上面，也就是说，如果它的光芒很大，盖过那些收费的模板，那不就亏了吗。</p><p>总的来看，abc theme 有几个不足之处，作为一个强迫症，必须要改善的地方吧：</p><ul><li><strong>没有返回顶部的按钮，这个功能大多数时候都会被使用者忽略，但是当你想用它却发现它不存在的时候，内心肯定是崩溃的</strong></li><li><strong>主页部分，标题日期标签全都是居中，有点别扭，不提供内容预览的功能(ghost是提供这个功能的)</strong></li><li><strong>不带搜索功能，可以通过lunr.js为博客增加搜索功能</strong></li></ul><h3 id="返回顶部按钮"><a href="#返回顶部按钮" class="headerlink" title="返回顶部按钮"></a>返回顶部按钮</h3><p>返回顶部其实很简单，只有记住有下面几个功能就好：</p><ul><li>窗口在顶端或靠近顶端的时候，返回顶部按钮要隐藏</li><li>窗口不在顶端，点击返回顶部按钮，当前窗口会返回到顶端</li></ul><p>在<code>deflaut.hbs</code>中添加按钮的html标签：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="javascript">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"back-to-top js-back-to-top-btn hidden"</span>&gt;
	<span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-angle-up"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>
	<span class="comment">//这里的图标定义成用的fa样式，也可以改成自定义的图片</span>
&lt;<span class="regexp">/div&gt;</span></code></pre></td></tr></table></figure><p><code>hidden</code>表示默认情况下是隐藏的，隐藏属性可以通过css来设置，定义button的css样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><code class="css"><span class="selector-class">.back-to-top</span> &#123;
	<span class="attribute">background</span>:<span class="number">#d9d9d9</span>;
	<span class="attribute">color</span>:<span class="number">#000</span>;
	<span class="attribute">position</span>:fixed;
	<span class="attribute">bottom</span>:<span class="number">0</span>;
	<span class="attribute">right</span>:<span class="number">1.5625rem</span>;
	<span class="attribute">width</span>:<span class="number">3.125rem</span>;
	<span class="attribute">height</span>:<span class="number">2.5rem</span>;
	<span class="attribute">line-height</span>:<span class="number">2.5rem</span>;
	<span class="attribute">text-align</span>:center;
	<span class="attribute">cursor</span>:pointer;
	<span class="attribute">-webkit-transition</span>:all .<span class="number">4s</span>;
	<span class="attribute">transition</span>:all .<span class="number">4s</span>;
	<span class="attribute">border-radius</span>:<span class="number">0.1875rem</span> <span class="number">0.1875rem</span> <span class="number">0</span> <span class="number">0</span>;
	<span class="attribute">z-index</span>:<span class="number">99999</span>;
	<span class="attribute">-webkit-transform</span>:<span class="built_in">translateZ</span>(0);
	<span class="attribute">transform</span>:<span class="built_in">translateZ</span>(0)
&#125;
<span class="selector-class">.back-to-top</span><span class="selector-class">.hidden</span> &#123;
	<span class="attribute">bottom</span>:-<span class="number">2.5rem</span>
&#125;
<span class="selector-class">.back-to-top</span><span class="selector-pseudo">:hover</span> &#123;
	<span class="attribute">background</span>:<span class="number">#bfbfbf</span>
&#125;</code></pre></td></tr></table></figure><p>点击按钮，返回顶部，需要通过js来实现，之前需导入jquery库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><code class="javascript">goToTop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;
	<span class="keyword">var</span> backToTopButton = $(<span class="string">'.js-back-to-top-btn'</span>);
	<span class="keyword">if</span>($(backToTopButton).length) &#123;
		$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;
			<span class="keyword">if</span> ($(<span class="keyword">this</span>).scrollTop() &gt; <span class="number">300</span>) &#123;
				$(backToTopButton).removeClass(<span class="string">'hidden'</span>);
			&#125; <span class="keyword">else</span> &#123;
				$(backToTopButton).addClass(<span class="string">'hidden'</span>);
			&#125;
		&#125;);
		$(backToTopButton).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;
			$(<span class="string">'body,html'</span>).animate(&#123;
				<span class="attr">scrollTop</span>: <span class="number">0</span>
			&#125;, <span class="number">800</span>);
		&#125;);
	&#125;
&#125;</code></pre></td></tr></table></figure><h3 id="主页的美化"><a href="#主页的美化" class="headerlink" title="主页的美化"></a>主页的美化</h3><p>每个人的审美观都不一样，所有，自己喜欢的才是最好的。</p><p>之前也说了，居中的文字看起来确实是很别扭的，通过<code>text-align</code>让文字左对齐，接着依次添加内容。</p><p><strong>时间</strong>放在最上面，套一个<code>&lt;time&gt;</code>标签<code>&lt;time class=&quot;post-date&quot; datetime=&quot;\{\{date format=&#39;YYYY-MM-DD&#39;\}\}&quot;&gt;\{\{date format=&quot;YYYY-MM-DD&quot;\}\}&lt;/time&gt;</code></p><p><strong>标题</strong>：<code>&lt;h2 class=&quot;post-title&quot;&gt;&lt;a href=&quot;\{\{url\}\}&quot;&gt;\{\{\{title\}\}\}&lt;/a&gt;&lt;/h2&gt;</code></p><p><strong>标签</strong>：<code>&lt;section class=&quot;post-meta&quot;&gt;\{\{tags prefix=&quot; 标签 ： &quot;\}\}&lt;/section&gt;</code></p><p><strong>内容预览</strong>：<code>&lt;section class=&quot;post-desc&quot;&gt;\{\{excerpt characters=&quot;120&quot;\}\} ...&lt;/section&gt;</code></p><p>有一些细小的地方需要注意，比如四周黑色的边框，感觉宽度有点太宽了，把宽度调小。这是一个自适应的网站，当宽度缩小时，边框又感觉是累赘，算了，屏幕宽度小到一定程度的时候把他们隐藏吧。</p><p>我把自己使用的这个主题放到Github上，<a href="https://github.com/songjinzhong/GhostTheme_sjz" target="_blank" rel="external">地址在这</a>，喜欢的小伙伴，可以下载。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/07/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的建站路2：免费的 Ghost 主题</title>
      <link>http://yuren.space/blog/2016/08/04/%E5%85%8D%E8%B4%B9%E7%9A%84Ghost%E4%B8%BB%E9%A2%98/</link>
      <guid>http://yuren.space/blog/2016/08/04/%E5%85%8D%E8%B4%B9%E7%9A%84Ghost%E4%B8%BB%E9%A2%98/</guid>
      <pubDate>Thu, 04 Aug 2016 13:26:35 GMT</pubDate>
      <description>
      
        我的建站路2：免费的 Ghost 主题
      
      </description>
      
      <content:encoded><![CDATA[<p>Ghost是免费的博客平台，它有一个自己的自适应博客界面，样子一般，后台用的是handlebars.js模板，所有，我们可以设计自己的主题。</p><p>重点是，我一点灵感都没有！</p><a id="more"></a><p>还好，毕竟Ghost是一个庞大的开源平台，手下的主题数不胜数，当然，漂亮的一塌糊涂的主题，肯定是收费的，下面收集了2个网址：</p><p><a href="http://marketplace.ghost.org/" target="_blank" rel="external">Ghost官方主题市场</a></p><p><a href="https://www.ghostforbeginners.com" target="_blank" rel="external">https://www.ghostforbeginners.com</a></p><p>其次，Github上面也有免费的分享主题，我选了一个黑色简约的主题 <strong>abc</strong> Theme，<a href="http://pxt.be/" target="_blank" rel="external">官网在这</a>，<a href="http://abc.pxt.be/" target="_blank" rel="external">演示地址在这</a>。</p><h3 id="变更主题"><a href="#变更主题" class="headerlink" title="变更主题"></a>变更主题</h3><p>Ghost主题默认放在<code>/content/themes/</code>文件夹下面，之前说的那个很一般的主题叫做Casper，是Ghost默认的。把下载好的主题放到该目录下，需要重启服务器，登陆Ghost后台，选择自己的新主题，保存。</p><h3 id="关于Handlebars"><a href="#关于Handlebars" class="headerlink" title="关于Handlebars"></a>关于Handlebars</h3><p><a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebars</a>是Ghost使用的模版语言。</p><p>Handlebars 提供了可以使你轻松高效地建立语义模版的功能。如果你想学 handlebars ，可以先熟悉熟悉它的语法，看看 <a href="http://handlebarsjs.com/expressions.html" target="_blank" rel="external">handlebars 文档</a></p><p><strong>写到这里，我发现官网有个<a href="http://docs.ghost.org/zh/themes" target="_blank" rel="external">中文版的介绍</a>，直接贴过来啦，实在不想写啦。。。</strong></p><h3 id="关于Ghost主题"><a href="#关于Ghost主题" class="headerlink" title="关于Ghost主题"></a>关于Ghost主题</h3><p>Ghost 的主题旨在做到易于编写和维护。Ghost 主题推崇模版（HTML）和业务逻辑（JavaScript）之间的分离。Handlebars （几乎）是没有逻辑，并且强化了这个分离，同时提供部件来帮助用来显示内容的业务逻辑保持独立。这种分离使在制作主题时，开发者和设计师之间的合作更加容易。</p><p>Handlebars 模版是分等级的（一个模版可以扩展另一个），也支持模块化的模版。Ghost 拥有这些特性，使得代码的重复得以减少，同时每一个模版可以保持专注于实现单一功能，并且做到好。拥有良好架构的主题将很容易维护，而各个组成部分之间的分离使得他们可以在不同主题之间重复利用。</p><p>希望你喜欢我们构造主题的方法。</p><h3 id="Ghost-主题的文件架构"><a href="#Ghost-主题的文件架构" class="headerlink" title="Ghost 主题的文件架构"></a>Ghost 主题的文件架构</h3><p>我们推荐如下架构：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="1c">.
├── /assets
<span class="string">|   └── /css</span>
<span class="string">|       ├── screen.css</span>
<span class="string">|   ├── /fonts</span>
<span class="string">|   ├── /images</span>
<span class="string">|   ├── /js</span>
├── default.hbs
├── index.hbs [必需]
└── post.hbs [必需]</code></pre></td></tr></table></figure><p>目前default.hbs和其他目录都不是必要的。 <code>index.hbs</code> 和 <code>post.hbs</code> 是必须的 – 如果这两个模板文件不存在的话，Ghost就无法正常运行。 <code>partials</code> 是一个特殊的目录。 这个目录应该包含所有你想要在整个博客范围内使用的模板文件，比如 <code>list-post.hbs</code> 可能是一个以列表形式展现一篇篇文章的模板文件，这个文件可能会被用于首页，之后可能被用于文章归档及标签页。 <code>partials</code> 也应该存放那些你想要覆盖的有特定功能的缺省模板文件比如分页。 在<code>partials</code>目录中添加<code>pagination.hbs</code>文件可以让你自定义分页的HTML。</p><blockquote><p>这是转移的博客，然后由于 MarkDown 的渲染方式不一样，先前的 MarkDown 在 Hexo 里报错，针对好恶心，所有请移步 <a href="http://blog.songjz.cn/wo-de-jian-zhan-lu-2-mian-fei-de-ghostzhu-ti/" target="_blank" rel="external">原站</a> 或者 直接访问 Ghost 的官网<a href="http://docs.ghost.org/zh/themes" target="_blank" rel="external">Ghost中文</a>。</p></blockquote>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/04/%E5%85%8D%E8%B4%B9%E7%9A%84Ghost%E4%B8%BB%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>解决服务器 err incomplete chunked encoding 问题</title>
      <link>http://yuren.space/blog/2016/08/03/err-incomplete-chunked-encoding/</link>
      <guid>http://yuren.space/blog/2016/08/03/err-incomplete-chunked-encoding/</guid>
      <pubDate>Wed, 03 Aug 2016 14:24:03 GMT</pubDate>
      <description>
      
        解决 服务器 err incomplete chunked encoding 问题
      
      </description>
      
      <content:encoded><![CDATA[<p>今天想把网站用非root用户启动，于是就修改了网站的启动用户，然后发现了当浏览器打开某些带有chunked网页的时候，会出现无响应的情况，通过调试，错误如下：</p><p><strong>net::ERR _INCOMPLETE _CHUNKED _ENCODING</strong></p><a id="more"></a><p>翻译过来就是错误不完整分块编码，分块编码是一种HTTP协议，处理较大的数据时，因不能确定数据大小，需要一部分一部分发送，这个时候就需要服务器进行处理。</p><p>因为只修改过服务器的用户权限，所有觉得应该是服务器的问题。然后就查看nginx的log日志：</p><p><img src="/content/images/2016/08/nginx-error3.png" alt=""></p><p>可以看出是服务器权限出现问题,然后查看nginx目录：</p><p><img src="/content/images/2016/08/nginx-error4.png" alt=""></p><p>有几个文件夹的所有者居然是nobody，nobody是什么鬼？解决办法就是：</p><p><strong>我先修改文件夹权限，发现运行时还是会变成nobody，估计是个bug，无奈之下，把nginx卸载，以当前用户重新安装，然后问题就解决了</strong>。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/03/err-incomplete-chunked-encoding/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的建站路1：Ghost 博客平台</title>
      <link>http://yuren.space/blog/2016/08/02/Ghost%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</link>
      <guid>http://yuren.space/blog/2016/08/02/Ghost%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</guid>
      <pubDate>Tue, 02 Aug 2016 14:53:23 GMT</pubDate>
      <description>
      
        建站 Ghost 博客 平台
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="空间和域名"><a href="#空间和域名" class="headerlink" title="空间和域名"></a>空间和域名</h3><p>关于空间和域名，不想说太多，如果你真心想建立一个自己的网站的话，这两个是必须要弄的。</p><a id="more"></a><p>我的服务器用的腾讯云的服务器，域名用的也是腾讯的，国内做的比较好的还有阿里云（其实我只知道这两家），国外的知道不少，像Godaddy、securedservers、codero等，当然还有一些便宜的可以做带理的vps服务器。</p><p>我的服务器用的系统是Ubuntu Server 14.04 64位，刚买的时候想尝试一下centos，发现用的不习惯，就重装成ubuntu，还是Ubuntu的命令比较习惯。配置是最便宜的，1G内存，1核CPU，20GB的硬盘，只是搭一个简单的个人博客，这些配置就已经足够了。</p><p>至于域名，是用来映射IP的，其实完全可以不用申请域名，通过IP就可以访问到你的网站。人靠衣装，域名可以方便别人记住你的网站。腾讯有它自己的域名解析，还是免费的，顺便也就用了。因为我申请的是国内.cn的域名，天朝的网站都是要审核的，大概花了两个星期的时间吧，提交材料还碰到许多问题，非常麻烦。如果嫌麻烦可以直接买国外的域名，简单方便，最好支持支付宝就好了，不要让支付成为累赘。</p><p>到此，建站的三大要素都有了，服务器，域名和域名解析。关于域名解析，因为是第一次用，感觉挺有意思的，不过我自己吃过亏，在解析的时候。下面这个图是我的域名解析信息：</p><p><img src="/content/images/2016/08/----.png" alt=""></p><p>我的域名是songjz.cn，主机记录www表示当访问www.songjz.cn的时候指向的ip，*表示匹配所有*.songjz.cn，@表示匹配songjz.cn，具体如下图</p><p><img src="/content/images/2016/08/----2-1.png" alt=""></p><h3 id="Ghost-开源的博客平台"><a href="#Ghost-开源的博客平台" class="headerlink" title="Ghost 开源的博客平台"></a>Ghost 开源的博客平台</h3><p>下面就是安装Ghost了，现在还需要连接服务器的两个工具<code>Xshell</code>和<code>Xftp</code>，都是免费的。</p><p>通过Xshell连接到Ubuntu服务器，update后先安装<code>nodejs</code>：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="elixir">root<span class="variable">@server1</span><span class="symbol">:~</span><span class="comment"># sudo apt-get update</span>
root<span class="variable">@server1</span><span class="symbol">:~</span><span class="comment"># sudo apt-get install nodejs</span></code></pre></td></tr></table></figure><p>安装nodejs的同时，也会把npm也一起安装：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="elixir">root<span class="variable">@server1</span><span class="symbol">:~</span><span class="comment"># node -v</span>
v4.<span class="number">4.7</span>
root<span class="variable">@server1</span><span class="symbol">:~</span><span class="comment"># npm -v</span>
<span class="number">1.3</span>.<span class="number">10</span></code></pre></td></tr></table></figure><p>下面开始安装Ghost，通过<a href="https://ghost.org/developers/" target="_blank" rel="external">Ghost下载界面</a>下载最新版，通过Xftp把文件上传到服务器的自定义位置。（如果没有高级root权限，建议放到当前用户的目录下，防止权限不足问题）</p><p>通过<code>unzip</code>或<code>tar</code>解压刚才的文件（这要看下载的文件是.zip还是.tar.gz），然后执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="sql">cd ghost
npm <span class="keyword">install</span> <span class="comment">--production</span></code></pre></td></tr></table></figure><p>Ghost博客需要的库较多，需要安装一会。</p><p>复制一份config.example.js为config.js，用vim打开：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><code class="css"><span class="selector-tag">production</span>: &#123;
    <span class="attribute">url</span>: <span class="string">'http://blog.songjz.cn'</span>,
	//将上面url修改为自己的博客主页
    mail: &#123;&#125;,
    <span class="selector-tag">database</span>: &#123;
        <span class="attribute">client</span>: <span class="string">'sqlite3'</span>,
        connection: &#123;
            filename: path.<span class="built_in">join</span>(__dirname, <span class="string">'/content/data/ghost.db'</span>)
        &#125;,
        <span class="selector-tag">debug</span>: <span class="selector-tag">false</span>
    &#125;,
    <span class="selector-tag">server</span>: &#123;
        <span class="attribute">host</span>: <span class="string">'127.0.0.1'</span>,
		//host修改成<span class="string">'0.0.0.0'</span>
        port: <span class="string">'2368'</span>
		//运行的端口，把端口设置成<span class="string">'80'</span>
    &#125;
&#125;,</code></pre></td></tr></table></figure><p>基本配置完成，然后：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="oxygene">root@server1:~# node <span class="keyword">index</span>.js
WARNING: Ghost <span class="keyword">is</span> attempting <span class="keyword">to</span> use a direct <span class="function"><span class="keyword">method</span> <span class="title">to</span> <span class="title">send</span> <span class="title">email</span>.
<span class="title">It</span> <span class="title">is</span> <span class="title">recommended</span> <span class="title">that</span> <span class="title">you</span> <span class="title">explicitly</span> <span class="title">configure</span> <span class="title">an</span> <span class="title">email</span> <span class="title">service</span>.
<span class="title">Help</span> <span class="title">and</span> <span class="title">documentation</span> <span class="title">can</span> <span class="title">be</span> <span class="title">found</span> <span class="title">at</span> <span class="title">http</span>:</span><span class="comment">//support.ghost.org/mail.</span>

Migrations: Up-<span class="keyword">to</span>-date at version <span class="number">004</span>
Ghost <span class="keyword">is</span> running <span class="keyword">in</span> development...
Listening <span class="keyword">on</span> <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">80</span>
Url configured <span class="keyword">as</span>: http:<span class="comment">//blog.songjz.cn</span>
Ctrl+C <span class="keyword">to</span> shut down</code></pre></td></tr></table></figure><p>报了一个warning，是因为没有配置邮件。实际上Ghost是一个多人博客平台，通过邮件邀请他人一起写博客，这个先不管。</p><p>这个时候就可以通过浏览器访问主页了，如果域名和解析暂时无法使用的时候，也可以通过主机的ip来直接访问。比如<a href="http://115.159.219.205。" target="_blank" rel="external">http://115.159.219.205。</a></p><h3 id="Forever和Nginx"><a href="#Forever和Nginx" class="headerlink" title="Forever和Nginx"></a>Forever和Nginx</h3><p>这个时候通过ctrl+c或关闭Xshell，Ghost的运行就会停止，如何让Ghost后台运行？</p><p>Forever是一个简单的命令式nodejs的守护进程，创建、自动重启node进程，输出node日志，还可以同时开启多个node进程,可以通过<code>forever start</code>启动进程，<code>forever stop</code>关闭进程，<code>forever list</code>查看当前运行的进程列表：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="livecodeserver">npm install -g <span class="keyword">forever</span>
<span class="keyword">forever</span> <span class="built_in">start</span> index.js
<span class="keyword">forever</span> list</code></pre></td></tr></table></figure><p>Nginx 是一个高性能的HTTP和反向代理服务器，以它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。</p><p>所谓的反向代理，就是通过不同的域名映射到同一个ip，比如songjz.cn的域名只能对应一个115.159.219.205ip地址，而浏览器输入一般都是默认访问80端口，所以我输入www.songjz.cn和blog.songjz.cn都是访问服务器的80端口。</p><p>那么我想要输入www.songjz.cn的时候跳转到我的主页，输入blog.songjz.cn跳转到我博客的主页，其实也可以通过URL解析来实现，例如访问博客页www.songjz.cn/blog。</p><p>现在有一个问题，Ghost是一个独立的nodejs应用，想要通过URL解析很难实现，而nginx的反向代理就可以很轻松实现。原理是先通过80端口访问nginx，nginx判断不同的三级域名，转给其它端口。</p><p><a href="http://nginx.org/en/download.html" target="_blank" rel="external">nginx的下载页面</a>我用的是1.81的稳定版本。</p><p>将nginx安装包通过Xftp复制到服务器中，解压到/usr/local目录下:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="vim"><span class="keyword">cd</span> nginx
./configure
<span class="keyword">make</span></code></pre></td></tr></table></figure><p>打开conf/nginx.conf，修改配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><code class="nginx"><span class="section">http</span> &#123;
	<span class="attribute">include</span>       mime.types;
	<span class="attribute">default_type</span>  application/octet-stream;
	<span class="attribute">sendfile</span>        <span class="literal">on</span>;
	<span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;
	<span class="comment">#pool</span>
	<span class="attribute">upstream</span> blog_pool&#123;
		<span class="attribute">server</span> <span class="number">127.0.0.1:5000</span>;<span class="comment">#这边开启端口5000</span>
	&#125;
	<span class="section">server</span> &#123;
		<span class="attribute">listen</span>       <span class="number">80</span>;
		<span class="attribute">server_name</span>  blog.songjz.cn;
		<span class="comment">#这句话就是把浏览器打开blog.songjz.cn提交给其它端口</span>
		<span class="attribute">location</span> / &#123;
			<span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;
			<span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;
			<span class="attribute">proxy_pass</span> http://blog_pool;
			<span class="comment">#调用前面建好的pool</span>
		&#125;
	&#125;</code></pre></td></tr></table></figure><p>增加nginx的环境变量，通过：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="arduino">nginx
<span class="comment">//开启nginx</span>
nginx -s <span class="built_in">stop</span>
<span class="comment">//关闭nginx</span></code></pre></td></tr></table></figure><p>这个时候再回到Ghost的目录下，把config.js开启端口设置成5000，重启Ghost，通过blog.songjz.cn就可以访问Ghost的主页。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/02/Ghost%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>处理 Http 协议中的 chunked 数据错位问题</title>
      <link>http://yuren.space/blog/2016/08/01/chunked%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</link>
      <guid>http://yuren.space/blog/2016/08/01/chunked%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Mon, 01 Aug 2016 12:16:32 GMT</pubDate>
      <description>
      
        处理 Http 协议 chunked 数据 错位 问题
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>问题</strong></p><blockquote><p>由于<code>网页数据</code>编码和<code>python</code>编辑器默认编码不同导致数据处理错位。</p></blockquote><a id="more"></a><p>先来介绍一下分块传输编码。</p><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。</p><p>通常，HTTP应答消息中发送的数据是整个发送的，<strong>Content-Length</strong>消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。<strong>然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</strong>通常数据块的大小是一致的，但也不总是这种情况。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p><ul><li>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</li><li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li><li>HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。<strong>在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。</strong>在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF（回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。</p><p>最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。</p><p>消息最后以CRLF结尾。例如下面就是一个chunked格式的响应体。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><code class="http">HTTP/1.1 <span class="number">200</span> OK
<span class="attribute">Date</span>: Wed, 06 Jul 2016 06:59:55 GMT
<span class="attribute">Server</span>: Apache
<span class="attribute">Accept-Ranges</span>: bytes
<span class="attribute">Transfer-Encoding</span>: chunked
<span class="attribute">Content-Type</span>: text/html
<span class="attribute">Content-Encoding</span>: gzip
<span class="attribute">Age</span>: 35
<span class="attribute">X-Via</span>: 1.1 daodianxinxiazai58:88 (Cdn Cache Server V2.0), 1.1 yzdx147:1 (Cdn Cache Server V2.0)
<span class="attribute">Connection</span>: keep-alive

<span class="cos">a
..<span class="built_in">..k</span>.|<span class="keyword">W</span>..
<span class="number">166</span>
<span class="built_in">..OO</span>.0...&amp;~..<span class="comment">;........]..(F=V.A3.X..~z...-.l8......y....).?....,....j..h .6....s.~.&gt;..mZ .8/..,.)B.G.`"Dq.P].f=0..Q..d.....h......8....F..y......q.....4&#123;F..M.A.*..a.rAra.... .n&gt;.D</span>
<span class="built_in">..o</span>@.`^.....!@ $.<span class="built_in">..p</span>...<span class="built_in">%a</span>\<span class="keyword">D</span><span class="built_in">..K</span>.. .<span class="keyword">d</span>&#123;<span class="number">2.</span><span class="built_in">..UnF</span>,C[..<span class="built_in">..T</span>...<span class="built_in">..c</span>..<span class="built_in">..V</span>....<span class="string">"%.`U......?D....#..K..&lt;.....D.e....IFK0.&lt;...)]K.V/eK.Qz...^....t...S6...m...^..CK.XRU?m...........Z..#Uik......</span></span></code></pre></td></tr></table></figure><p>从响应体中可以看到，数据分为两部分，第一部分的头长度是16进制的<code>a</code>，表示<code>10</code>个字节，内容为<code>....k.|W..</code>。第二部分长度为<code>166</code>，换算成16进制是256+96+6=<code>358</code>个字节。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>从前面的介绍可以知道，response-body部分其实由length(1) \r\n data(1) \r\n length(2) \r\n data(2)……循环组成，通过下面的函数进行处理，再根据压缩类型解压出最终的数据。<br>处理的过程如下：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><code class="hsp">unchunked = b<span class="string">''</span>
<span class="keyword">pos</span> = <span class="number">0</span>
<span class="keyword">while</span> <span class="keyword">pos</span> &lt;= len(data):
	chunkNumLen = data.find(b<span class="string">'\r\n'</span>, <span class="keyword">pos</span>)-<span class="keyword">pos</span>
	<span class="comment">//从第一个元素开始，发现第一个\r\n，计算length长度</span>
	chunkLen=<span class="keyword">int</span>(data[<span class="keyword">pos</span>:<span class="keyword">pos</span>+chunkNumLen], <span class="number">16</span>)
	<span class="comment">//把length的长度转换成int</span>
	<span class="keyword">if</span> chunkLen == <span class="number">0</span>:
		<span class="keyword">break</span>
		<span class="comment">//如果长度为0，则说明到结尾</span>
	chunk = data[<span class="keyword">pos</span>+chunkNumLen+len(<span class="string">'\r\n'</span>):<span class="keyword">pos</span>+chunkNumLen+len(<span class="string">'\r\n'</span>)+chunkLen]
	unchunked += chunk
	<span class="comment">//将压缩数据拼接</span>
	<span class="keyword">pos</span> += chunkNumLen+len(<span class="string">'\r\n'</span>)+chunkLen+len(<span class="string">'\r\n'</span>)
	<span class="comment">//同时pos位置向后移动</span>

<span class="keyword">return</span> unchunked
<span class="comment">//unchunked就是普通的压缩数据，可以用解压函数进行解压</span></code></pre></td></tr></table></figure><h3 id="New-Problem"><a href="#New-Problem" class="headerlink" title="New Problem"></a>New Problem</h3><p>今天在又碰到了一个问题，就是在处理部分数据包的时候，有的网页编码是<code>utf-8</code>，服务器在压缩数据的时候，被压缩数据的类型也就是<code>utf-8</code>，如果python编辑器的代码没有把<code>data</code>编码成encode(‘’utf-8)，长度显然就会报错，此时代码需要做稍微改动，在头部加入下面这句话：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="haskell"><span class="class"><span class="keyword">data</span>=<span class="keyword">data</span>.encode('<span class="title">utf</span>-8')</span>
//这里的utf<span class="number">-8</span>要根据实际情况而定，如果网页的编码是gbk，需要encode(‘gbk’)</code></pre></td></tr></table></figure><p>当然，如果数据还要以其他编码进行后续处理，在最后还要加上<code>data=data.encode(&quot;需要的编码&quot;)</code>。</p><p>至于如何判断数据包的编码方式，可以通过网页的Head部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/HTML; charset=utf-8"</span>&gt;</span></code></pre></td></tr></table></figure><p>数据包形式多种多样，实际处理的时候，要根据具体情况而定。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/08/01/chunked%E6%95%B0%E6%8D%AE%E9%94%99%E4%BD%8D%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Unicode Decode Error: python 如何解决汉字编码问题</title>
      <link>http://yuren.space/blog/2016/07/31/python%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <guid>http://yuren.space/blog/2016/07/31/python%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Sun, 31 Jul 2016 14:42:21 GMT</pubDate>
      <description>
      
        Python Unicode Decode Error 解决 汉字 编码 问题
      
      </description>
      
      <content:encoded><![CDATA[<p>由于项目需要，需要读取一个含有中文的txt文档，完了还要保存文件。文档之前是由base64编码，导致所有汉字读取显示乱码。项目组把base64废弃之后，先后出现两个错误：</p><ul><li><strong>ascii codec can’t encode characters in position ordinal not in range 128</strong></li><li><strong>UnicodeDecodeError: ‘utf8’ codec can’t decode byte 0x</strong>。</li></ul><a id="more"></a><p>如果对于ascii、unicode和utf-8还不了解的小伙伴，可以看之前的这篇博客<a href="http://blog.songjz.cn/guan-yu-zi-fu-chuan-he-bian-ma/" target="_blank" rel="external">关于字符串和编码</a></p><p>那么必须对下面这三个概念有所了解：</p><ul><li>ascii只能表示数字、英文字母和一些特殊符号，不能表示汉字</li><li>unicode和utf-8都可以表示汉字，unicode是固定长度，utf-8是可变长度</li><li>内存中存储方式一般为unicode，而磁盘文件存储方式一般为utf-8，因为utf-8可以节约存储空间</li></ul><p>那么python的默认编码是什么？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; import sys
<span class="meta">&gt;&gt;</span>&gt; sys.getdefaultencoding()
<span class="string">'ascii'</span>
<span class="meta">&gt;&gt;</span>&gt; reload(sys)
&lt;<span class="class"><span class="keyword">module</span> '<span class="title">sys</span>' (<span class="title">built</span>-<span class="title">in</span>)&gt;</span>
<span class="meta">&gt;&gt;</span>&gt; sys.setdefaultencoding(<span class="string">'utf-8'</span>)
<span class="meta">&gt;&gt;</span>&gt; sys.getdefaultencoding()
<span class="string">'utf-8'</span></code></pre></td></tr></table></figure><p>python的默认编码是<code>ascii</code>，可以通过<code>sys.setdefaultencoding(&#39;utf-8&#39;)</code>函数设置python的默认编码。</p><p>python中可以通过<code>encode</code>和<code>decode</code>的方式改变数据的编码，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="python"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'汉字'</span>
<span class="string">u'\u6c49\u5b57'</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">u'汉字'</span>.encode(<span class="string">'utf-8'</span>)
<span class="string">'\xe6\xb1\x89\xe5\xad\x97'</span>
<span class="meta">&gt;&gt;&gt; </span><span class="string">u'汉字'</span>.encode(<span class="string">'utf-8'</span>).decode(<span class="string">'utf-8'</span>)
<span class="string">u'\u6c49\u5b57'</span></code></pre></td></tr></table></figure><p>我们可以通过这两个函数设置编码。</p><p>那么，python中的str是什么类型？</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; import binascii
<span class="meta">&gt;&gt;</span>&gt; <span class="string">'汉字'</span>
<span class="string">'\xba\xba\xd7\xd6'</span>
<span class="meta">&gt;&gt;</span>&gt; type(<span class="string">'汉字'</span>)
&lt;type <span class="string">'str'</span>&gt;
<span class="meta">&gt;&gt;</span>&gt; print binascii.b2a_hex(<span class="string">'汉字'</span>)
babad7d6
<span class="meta">&gt;&gt;</span>&gt; print binascii.b2a_hex(u<span class="string">'汉字'</span>)
Traceback (most recent call last):
  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span>
<span class="symbol">UnicodeEncodeError:</span> <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in
position 0-1: ordinal not in range(128)
&gt;&gt;&gt; print binascii.b2a_hex(u'</span>汉字<span class="string">'.encode('</span>utf-<span class="number">8</span><span class="string">'))
e6b189e5ad97
&gt;&gt;&gt; print binascii.b2a_hex(u'</span>汉字<span class="string">'.encode('</span>gbk<span class="string">'))
babad7d6</span></code></pre></td></tr></table></figure><p><code>binascii</code>是将数据的二进制转换成ascii，上面的解释是：‘汉字’的类型是<code>str</code>，二进制是<code>babad7d6</code>，u‘汉字’是无法转换成ascii，这样就报出了开头的第一个错误。解决办法就是把它.encode(‘utf-8’)成<code>str</code>类型。因为我命令行是windows默认的GBK编码，所有u’汉字’.encode(‘gbk’)的时候，输出结果和‘汉字’结果一样。</p><p>总结一下，python的<code>str</code>实际上是unicode的一种，python的默认编码是ascii，对于非ascii转成ascii的时候都会报错，牢记下面的规则：</p><ul><li><strong>unicode =&gt; encode(‘合适的编码’) =&gt; str</strong></li><li><strong>str =&gt; decode(‘合适的编码’) =&gt; unicode</strong></li></ul><p>还有一种简单的方式，就是在文件头设置编码，可以省去很多麻烦：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="stylus">import sys
<span class="function"><span class="title">reloads</span><span class="params">(sys)</span></span>
sys.setdefaultencoding(<span class="string">'utf-8'</span>)</code></pre></td></tr></table></figure><p>对于第二个问题，是在文件读取的时候出的错。utf-8的文件有bom和无bom两种方式，两者的差别好像在bom文件比无bom文件多了一个头，导致以utf-8方式读文件时报错，我先前曾尝试读文件的时候先对有无bom进行判断，跳过bom文件的头，后来失败了⊙﹏⊙真尴尬～～。</p><p>还得上google求助大神，<a href="http://stackoverflow.com/questions/12468179/unicodedecodeerror-utf8-codec-cant-decode-byte-0x9c" target="_blank" rel="external">原帖在这</a>，具体的操作方法就是使用<code>codecs</code>库来读文件（我猜这个库就是对文件的头进行检测）。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="arduino"><span class="keyword">import</span> codecs
codecs.<span class="built_in">open</span>(file_name, <span class="string">"r"</span>,encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>)</code></pre></td></tr></table></figure><p>对于编码问题，一定要懂得<code>ascii</code>、<code>unicode</code>和<code>utf-8</code>工作原理。</p><p>今天就写到这吧。</p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/07/31/python%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于字符串和编码</title>
      <link>http://yuren.space/blog/2016/07/30/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</link>
      <guid>http://yuren.space/blog/2016/07/30/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/</guid>
      <pubDate>Sat, 30 Jul 2016 03:10:35 GMT</pubDate>
      <description>
      
        关于 字符串 编码 Python
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>上周用Python写代码的时候，再次遇到头疼的编码问题，读写文件的时候出现“utf-8”的错误，网上找了资料把编码回顾了一下。</p><a id="more"></a><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</p><p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到<code>Shift_JIS</code>里，韩国把韩文编到<code>Euc-kr</code>里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p><p>字符编码问题真的令人头疼!</p><p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p><p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>&#39;0&#39;</code>和整数<code>0</code>是不同的；</p><p>汉字<code>中</code>已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p><p>你可以猜测，如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多<code>一倍</code>的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><p><img src="/content/images/2016/07/table.png" alt="table"></p><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p><strong>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</strong></p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p><img src="/content/images/2016/07/0.png" alt="rw-file-utf-8"></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="/content/images/2016/07/11.png" alt="web-utf-8"></p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。</p><p>在最新的Python 3版本中，字符串是以<strong>Unicode</strong>编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; print(<span class="string">'包含中文的str'</span>)
包含中文的str</code></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; ord(<span class="string">'A'</span>)
<span class="number">65</span>
<span class="meta">&gt;&gt;</span>&gt; ord(<span class="string">'中'</span>)
<span class="number">20013</span>
<span class="meta">&gt;&gt;</span>&gt; chr(<span class="number">66</span>)
<span class="string">'B'</span>
<span class="meta">&gt;&gt;</span>&gt; chr(<span class="number">25991</span>)
<span class="string">'文'</span></code></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'\u4e2d\u6587'</span>
<span class="string">'中文'</span></code></pre></td></tr></table></figure><p>两种写法完全是等价的。</p><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><code class="ini"><span class="attr">x</span> = b<span class="string">'ABC'</span></code></pre></td></tr></table></figure><p>要注意区分<code>&#39;ABC&#39;</code>和<code>b&#39;ABC&#39;</code>，前者是<code>str</code>，后者虽然内容显示得和前者一样，但<code>bytes</code>的每个字符都只占用一个字节。</p><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)
b<span class="string">'ABC'</span>
<span class="meta">&gt;&gt;</span>&gt; <span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)
b<span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>
<span class="meta">&gt;&gt;</span>&gt; <span class="string">'中文'</span>.encode(<span class="string">'ascii'</span>)
Traceback (most recent call last):
  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span>
<span class="symbol">UnicodeEncodeError:</span> <span class="string">'ascii'</span> codec can<span class="string">'t encode characters 
in position 0-1: ordinal not in range(128)</span></code></pre></td></tr></table></figure><p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p><p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; b<span class="string">'ABC'</span>.decode(<span class="string">'ascii'</span>)
<span class="string">'ABC'</span>
<span class="meta">&gt;&gt;</span>&gt; b<span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)
<span class="string">'中文'</span></code></pre></td></tr></table></figure><p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; len(<span class="string">'ABC'</span>)
<span class="number">3</span>
<span class="meta">&gt;&gt;</span>&gt; len(<span class="string">'中文'</span>)
<span class="number">2</span></code></pre></td></tr></table></figure><p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; len(b<span class="string">'ABC'</span>)
<span class="number">3</span>
<span class="meta">&gt;&gt;</span>&gt; len(b<span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>)
<span class="number">6</span>
<span class="meta">&gt;&gt;</span>&gt; len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))
<span class="number">6</span></code></pre></td></tr></table></figure><p>可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="d"><span class="meta">#!/usr/bin/env python3</span>
# -*- coding: utf-<span class="number">8</span> -*-</code></pre></td></tr></table></figure><p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><p>申明了UTF-8编码并不意味着你的<code>.py</code>文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用<strong>UTF-8 without BOM</strong>编码。</p><p><img src="/content/images/2016/07/2.png" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python 3的字符串使用Unicode，直接支持多语言。</p><p>str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="ruby"><span class="meta">&gt;&gt;</span>&gt; <span class="string">'中文'</span>.encode(<span class="string">'gb2312'</span>)
<span class="string">'\xd6\xd0\xce\xc4'</span></code></pre></td></tr></table></figure><p><strong>但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。</strong></p><p>格式化字符串的时候，可以用Python的交互式命令行测试，方便快捷。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="external">廖雪峰的字符串和编码教程</a></p>]]></content:encoded>
      
      <comments>http://yuren.space/blog/2016/07/30/%E5%85%B3%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
