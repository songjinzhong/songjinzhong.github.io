<!doctype html><html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="author" content="song"><meta name="description" content="处理 Http 协议 chunked 数据 错位 问题"><title>处理 Http 协议中的 chunked 数据错位问题 | 渔人</title><link rel="alternate" href="/blog/rss.xml" title="渔人"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/all.min.css"></head><body><div class="post"><h1 class="overview"><a href="/blog/rss.xml" class="web-feed" title="RSS订阅" target="_blank"></a> <i class="search-icon"></i> <a href="/">渔人</a> <font>» </font><a href="/blog">博客</a> <font>» </font><a href="/blog/archives">归档</a><div class="big-search"><i class="close-icon"></i><div class="search-container"><form class="search-form"><input class="search-input js-search-input" type="text" placeholder="请输入关键字"></form><div class="js-search-results"></div></div></div></h1><div class="post-info"><h1>处理 Http 协议中的 chunked 数据错位问题</h1><div class="author-info"><p class="author">作者:<a href="/">宋进忠</a></p><p class="date">时间: <span>2016/08/01</span></p><p class="cat-arc"><span>分类: <a href="/blog/categories/Http协议/">Http协议</a> </span><span>标签: <a href="/blog/tags/Http协议/">Http协议</a> / <a href="/blog/tags/chunked/">chunked</a></span></p></div></div><div class="post-markdown"><p><strong>问题</strong></p><blockquote><p>由于<code>网页数据</code>编码和<code>python</code>编辑器默认编码不同导致数据处理错位。</p></blockquote><p><img class="img-mid" src="http://ww3.sinaimg.cn/mw690/e3dde130gw1f8hjhe6x6yj20zk0p47au.jpg" alt="图片来源网上" title="图片来源于网络"></p><p>先来介绍一下分块传输编码。</p><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。</p><p>通常，HTTP应答消息中发送的数据是整个发送的，<strong>Content-Length</strong>消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。<strong>然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</strong>通常数据块的大小是一致的，但也不总是这种情况。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p><ul><li>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</li><li>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</li><li>HTTP服务器有时使用压缩 （gzip或deflate）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。<strong>在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出使用本文描述的方案进行分块传输。</strong>在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF（回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。</p><p>最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。</p><p>消息最后以CRLF结尾。例如下面就是一个chunked格式的响应体。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><code class="http">HTTP/1.1 <span class="number">200</span> OK
<span class="attribute">Date</span>: Wed, 06 Jul 2016 06:59:55 GMT
<span class="attribute">Server</span>: Apache
<span class="attribute">Accept-Ranges</span>: bytes
<span class="attribute">Transfer-Encoding</span>: chunked
<span class="attribute">Content-Type</span>: text/html
<span class="attribute">Content-Encoding</span>: gzip
<span class="attribute">Age</span>: 35
<span class="attribute">X-Via</span>: 1.1 daodianxinxiazai58:88 (Cdn Cache Server V2.0), 1.1 yzdx147:1 (Cdn Cache Server V2.0)
<span class="attribute">Connection</span>: keep-alive

<span class="cos">a
..<span class="built_in">..k</span>.|<span class="keyword">W</span>..
<span class="number">166</span>
<span class="built_in">..OO</span>.0...&amp;~..<span class="comment">;........]..(F=V.A3.X..~z...-.l8......y....).?....,....j..h .6....s.~.&gt;..mZ .8/..,.)B.G.`"Dq.P].f=0..Q..d.....h......8....F..y......q.....4&#123;F..M.A.*..a.rAra.... .n&gt;.D</span>
<span class="built_in">..o</span>@.`^.....!@ $.<span class="built_in">..p</span>...<span class="built_in">%a</span>\<span class="keyword">D</span><span class="built_in">..K</span>.. .<span class="keyword">d</span>&#123;<span class="number">2.</span><span class="built_in">..UnF</span>,C[..<span class="built_in">..T</span>...<span class="built_in">..c</span>..<span class="built_in">..V</span>....<span class="string">"%.`U......?D....#..K..&lt;.....D.e....IFK0.&lt;...)]K.V/eK.Qz...^....t...S6...m...^..CK.XRU?m...........Z..#Uik......</span></span></code></pre></td></tr></table></figure><p>从响应体中可以看到，数据分为两部分，第一部分的头长度是16进制的<code>a</code>，表示<code>10</code>个字节，内容为<code>....k.|W..</code>。第二部分长度为<code>166</code>，换算成16进制是256+96+6=<code>358</code>个字节。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>从前面的介绍可以知道，response-body部分其实由length(1) \r\n data(1) \r\n length(2) \r\n data(2)……循环组成，通过下面的函数进行处理，再根据压缩类型解压出最终的数据。<br>处理的过程如下：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><code class="hsp">unchunked = b<span class="string">''</span>
<span class="keyword">pos</span> = <span class="number">0</span>
<span class="keyword">while</span> <span class="keyword">pos</span> &lt;= len(data):
	chunkNumLen = data.find(b<span class="string">'\r\n'</span>, <span class="keyword">pos</span>)-<span class="keyword">pos</span>
	<span class="comment">//从第一个元素开始，发现第一个\r\n，计算length长度</span>
	chunkLen=<span class="keyword">int</span>(data[<span class="keyword">pos</span>:<span class="keyword">pos</span>+chunkNumLen], <span class="number">16</span>)
	<span class="comment">//把length的长度转换成int</span>
	<span class="keyword">if</span> chunkLen == <span class="number">0</span>:
		<span class="keyword">break</span>
		<span class="comment">//如果长度为0，则说明到结尾</span>
	chunk = data[<span class="keyword">pos</span>+chunkNumLen+len(<span class="string">'\r\n'</span>):<span class="keyword">pos</span>+chunkNumLen+len(<span class="string">'\r\n'</span>)+chunkLen]
	unchunked += chunk
	<span class="comment">//将压缩数据拼接</span>
	<span class="keyword">pos</span> += chunkNumLen+len(<span class="string">'\r\n'</span>)+chunkLen+len(<span class="string">'\r\n'</span>)
	<span class="comment">//同时pos位置向后移动</span>

<span class="keyword">return</span> unchunked
<span class="comment">//unchunked就是普通的压缩数据，可以用解压函数进行解压</span></code></pre></td></tr></table></figure><h3 id="New-Problem"><a href="#New-Problem" class="headerlink" title="New Problem"></a>New Problem</h3><p>今天在又碰到了一个问题，就是在处理部分数据包的时候，有的网页编码是<code>utf-8</code>，服务器在压缩数据的时候，被压缩数据的类型也就是<code>utf-8</code>，如果python编辑器的代码没有把<code>data</code>编码成encode(‘’utf-8)，长度显然就会报错，此时代码需要做稍微改动，在头部加入下面这句话：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><code class="haskell"><span class="class"><span class="keyword">data</span>=<span class="keyword">data</span>.encode('<span class="title">utf</span>-8')</span>
//这里的utf<span class="number">-8</span>要根据实际情况而定，如果网页的编码是gbk，需要encode(‘gbk’)</code></pre></td></tr></table></figure><p>当然，如果数据还要以其他编码进行后续处理，在最后还要加上<code>data=data.encode(&quot;需要的编码&quot;)</code>。</p><p>至于如何判断数据包的编码方式，可以通过网页的Head部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><code class="xml"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/HTML; charset=utf-8"</span>&gt;</span></code></pre></td></tr></table></figure><p>数据包形式多种多样，实际处理的时候，要根据具体情况而定。</p></div><div class="pre-next clear"><div class="pre-page"><i class="pre-icon"></i> <a href="/blog/2016/08/02/Ghost博客平台/">我的建站路1：Ghost 博客平台</a></div><div class="next-page"><a href="/blog/2016/07/31/python如何解决汉字编码问题/">Unicode Decode Error: python 如何解决汉字编码问题</a> <i class="next-icon"></i></div></div><div class="post-footer"><a href="/blog/rss.xml" class="post-feed" target="_black">Feed <i class="feed-icon"></i></a><h3>文档信息</h3><ul><li><span>版权声明：</span><span>自由转载-非商用-保持署名</span><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">(创意共享3.0许可证)</a></li><li><span>发表日期：</span><span>2016-08-01 20:16:32</span></li><li><span>本文分类：</span><span> <a href="/blog/categories/Http协议/">Http协议</a></span></li><li><span>本文标签：</span><span> <a href="/blog/tags/Http协议/">Http协议</a> / <a href="/blog/tags/chunked/">chunked</a></span></li><li><span>最后编辑：</span><span>2016-10-05 17:52:18</span></li><li><span>社交媒体：</span><span><a href="https://github.com/songjinzhong">GitHub<i class="github"></i></a><a href="http://weibo.com/3822969136">微博<i class="weibo"></i></a></span></li><li><span>分享文章：</span> <span><div class="ds-share" data-thread-key="blog/2016/08/01/chunked数据错位问题/" data-title="处理 Http 协议中的 chunked 数据错位问题" data-images="" data-content="问题由于网页数据编码和python编辑器默认编码不同导致数据处理错位。先来介绍一下分块传输编码。分块传输编码分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTT..." data-url="http://yuren.space/blog/2016/08/01/chunked数据错位问题/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></span></li></ul></div><div class="page-related"><h2>相关文章</h2><ul><li><span>2016.08.03</span><a href="/blog/2016/08/03/err-incomplete-chunked-encoding/">解决服务器 err incomplete chunked encoding 问题</a><p>今天想把网站用非root用户启动，于是就修改了网站的启动用户，然后发现了当...</p></li></ul></div><div class="duoshuo-part" id="comments"><div class="ds-thread" data-thread-key="blog/2016/08/01/chunked数据错位问题/" data-title="处理 Http 协议中的 chunked 数据错位问题" data-url="http://yuren.space/blog/2016/08/01/chunked数据错位问题/"></div><style type="text/css">.ds-sync{white-space:normal}.ds-post{transition:all .3s!important}.ds-post:hover{transition:all .3s!important;border-radius:5px!important;background:#F3F3F3!important}#ds-thread #ds-reset .ds-comments{border-bottom:none;padding:15px 0}#ds-thread #ds-reset .ds-powered-by{display:none}.ds-thread .ds-loading{padding:20px 0;text-align:center;color:#AFAFAF;background-color:#EFEFEF;border-radius:5px;line-height:30px;font-style:15px}#ds-thread .ds-loading{display:none;height:0;visibility:hidden}#ds-thread #ds-reset .ds-comments{border-bottom:none}#ds-thread #ds-reset a:hover,.ds-like-panel{color:#999}#ds-reset .ds-avatar,#ds-reset .ds-avatar img{border-radius:100%}#ds-thread #ds-reset li.ds-post{border-top:none}div#ds-thread #ds-reset .ds-comment-body p{color:#000}#ds-thread #ds-reset .ds-comment-body a{color:#777!important}#ds-thread #ds-reset li.ds-tab a{text-shadow:none}#ds-thread #ds-reset .ds-sort a.ds-current,#ds-thread #ds-reset .ds-sort a:active{color:#e58c7c}#ds-thread #ds-reset .ds-post-self{border-top:none}.ds-thread-like-text{display:block}.ds-thread-cancel-like{display:none}.ds-thread-liked .ds-thread-like-text{display:none}.ds-thread-liked .ds-thread-cancel-like{display:block}#ds-thread #ds-reset img{transition:all .3s}#ds-thread #ds-reset img:hover{transform:rotate(180deg);transition:all .3s}div#ds-thread #ds-reset .ds-comment-body{color:#555}#ds-thread #ds-reset .ds-comment-body a[data-user-id='6314610027441160961']::after{content:"博主";border:1px solid #e58c7c;border-radius:2px;margin-left:4px;color:#e58c7c;padding:0 2px;font-size:12px;line-height:14px;display:inline-block}.ds-post-reply,.ds-post-repost{display:none}.ds-post-self:hover .ds-post-reply,.ds-post-self:hover .ds-post-repost{display:inline}.ds-user-name{font-size:14px!important;line-height:42px!important}.ds-children .ds-user-name{line-height:26px!important}div#ds-thread #ds-reset .ds-comment-body p{font-size:16px!important}div#ds-thread #ds-reset .ds-comment-header .ds-user-name{font-size:18px!important;font-family:consolas!important;line-height:30px!important}div#ds-thread #ds-reset .ds-textarea-wrapper textarea{height:120px!important;font-size:16px!important;font-family:Consolas,Georgia,serif}@media (max-width:800px){div#ds-thread #ds-reset .ds-textarea-wrapper textarea{height:70px!important}}div#ds-thread #ds-reset .ds-post-options{overflow:hidden}div#ds-thread #ds-reset .ds-post-toolbar{box-shadow:none}div#ds-thread #ds-reset .ds-post-button{position:relative;margin-top:20px;font-size:16px}div#ds-thread #ds-reset .ds-post-options{margin-right:0!important;border-right:1px solid #CCC}@media screen and (max-width:641px){div#ds-thread #ds-reset .ds-replybox{padding:0!important}div#ds-thread #ds-reset .ds-replybox .ds-avatar{display:none!important}.ds-post-self:hover .ds-post-reply,.ds-post-self:hover .ds-post-report,.ds-post-self:hover .ds-post-repost{display:none!important}}div#ds-thread #ds-reset .ds-comment-body p{white-space:pre-wrap;font-family:consolas!important}#ds-thread #ds-reset .ds-paginator a{font-size:20px!important}#ds-thread #ds-reset .ds-login-buttons p{color:#999}#ds-thread #ds-reset .ds-comment-body{background:#fbfbfb;padding:15px 15px 12px 32px;border-radius:5px;box-shadow:0 1px 2px rgba(0,0,0,.15),0 1px 0 rgba(255,255,255,.75) inset}</style><script type="text/javascript">var duoshuoQuery={short_name:"songjz"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div><div class="web-info">Copyright © 2016-2017,本站由 <a href="/blog/web-info">本人</a> 手工打造,历时2周, <a href="/blog/web-info/#link">联系方式</a> <span>网站参考 <a href="http://www.barretlee.com/">小胡子哥</a>/ <a href="http://www.ruanyifeng.com/home.html">阮一峰老师</a></span></div></div><div class="tools"><i class="back-to-top" style="display:none"></i> <i class="goto-comments"></i></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/all.min.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?513bc3e28555252418b03cc8e660bc31";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-85346637-1","auto"),ga("send","pageview")</script></body></html>