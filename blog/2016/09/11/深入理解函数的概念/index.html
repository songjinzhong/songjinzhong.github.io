<!doctype html><html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="author" content="song"><meta name="description" content="JS 进阶 深入 理解 函数 概念"><title>JS 进阶之路 : 深入理解函数的概念 | 渔人</title><link rel="alternate" href="/blog/rss.xml" title="渔人"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/all.min.css"></head><body><div class="post"><h1 class="overview"><a href="/blog/rss.xml" class="web-feed" title="RSS订阅" target="_blank"></a> <i class="search-icon"></i> <a href="/">渔人</a> <font>» </font><a href="/blog">博客</a> <font>» </font><a href="/blog/archives">归档</a><div class="big-search"><i class="close-icon"></i><div class="search-container"><form class="search-form"><input class="search-input js-search-input" type="text" placeholder="请输入关键字"></form><div class="js-search-results"></div></div></div></h1><div class="post-info"><h1>JS 进阶之路 : 深入理解函数的概念</h1><div class="author-info"><p class="author">作者:<a href="/">宋进忠</a></p><p class="date">时间: <span>2016/09/11</span></p><p class="cat-arc"><span>分类: <a href="/blog/categories/JavaScript/">JavaScript</a> </span><span>标签: <a href="/blog/tags/JavaScript/">JavaScript</a> / <a href="/blog/tags/JS进阶/">JS进阶</a></span></p></div></div><div class="post-markdown"><p>之前一直觉得自己对 JavaScript 这门语言掌握的还可以，记得当初学这门语言的时候，也都是按照 Java 的思维去学的，以至于很多概念都没有弄明白。</p><p><img class="img-mid" src="http://ww4.sinaimg.cn/mw690/e3dde130gw1f8hrguoxdbj20zk0mjagh.jpg" alt="图片来源网上" title="图片来源于网络"></p><p>最近在 <a href="https://www.codewars.com">codewars</a> 做练习的时候，才发现，原理的东西，一个都没有搞懂，JS 最精华的函数、闭包都是在以自己的思维去揣测，而非真正的理解。之前看 《JavaScript 权威指南》，书中内容虽然说的很细，却没有说懂。</p><p>最近一周看了一下网上比较火的《JavaScript 忍者秘籍》，闭包、函数说的很清楚，不由感叹，真是一本进阶的好书呀。这本书帮我解决了很多困惑的问题，让我对 JS 这门语言有了深刻的认识，这一周，让我体会到了读书的愉悦，感觉学到了非常多的知识。</p><p>看书的时候，记了笔记，而我又想写点什么来记录下自己的成果，决定分几篇小博客来记录一下我的心得体会。</p><h3 id="JavaScript-中的函数"><a href="#JavaScript-中的函数" class="headerlink" title="JavaScript 中的函数"></a>JavaScript 中的函数</h3><p>JavaScript 中的函数形式多样，可以定义，也可以内联，这样子定义函数才有意思。</p><p>Java 是非函数式语言，而 JavaScript 中的函数式特性允许我们创建一个独立的实体函数，并将这个实体作为参数一样使用（这跟Python很像，不知道是谁先创的）。当别的函数或实体接收这个函数参数之后，就可以当作函数拿来用。</p><p>我在使用函数的时候，总结出这么一个特点，就是为什么有时候用 function()，而有时候用 function，（区别在于有没有括号）比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;
    <span class="comment">//do something</span>
    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);
&#125;
<span class="comment">//作为函数直接调用</span>
sayHello()  <span class="comment">// 'hello'</span>
<span class="comment">//作为函数参数传递</span>
<span class="keyword">var</span> say = sayHello; 
<span class="built_in">console</span>.log(<span class="keyword">typeof</span> say === <span class="string">'function'</span>) <span class="comment">//true</span>
say() <span class="comment">// 'hello'</span></code></pre></td></tr></table></figure><p>如果一个函数参数后面加了()，它就会立即执行，比如 <code>sayHello()</code>，就会跑到函数所在的位置把函数跑一边，这跟其他语言的函数调用一样；不加()会把函数作为参数传递。<code>var say = sayHello</code>，这个时候，say 变量也是函数变量，可通过 <code>say()</code>调用。</p><h3 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h3><p>关于函数内变量的作用域，必须要注意，否则变量会 undefined 的：</p><ol><li>函数内部的变量的作用域开始与声明的地方，结束于函数的结尾，与代码嵌套无关；</li><li>命名函数的作用域是指申明该函数所在区域的整个函数范围，与代码嵌套无关；</li><li>整个 window 是一个包含所有代码的超大型函数。</li></ol><p>第一个很好理解，在没有申明之前，变量无法使用，结束后也无法使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">theTest</span>(<span class="params"></span>)</span>&#123;
    <span class="built_in">console</span>.log(test); <span class="comment">//undefined</span>
    <span class="keyword">var</span> test = <span class="string">'hello'</span>;
    <span class="built_in">console</span>.log(test); <span class="comment">// 'hello'</span>
&#125;
theTest();
<span class="built_in">console</span>.log(test); <span class="comment">//error,</span></code></pre></td></tr></table></figure><p>第二个的意思大致是函数定义不像变量，不用考虑顺序，但要考虑作用域，及申明函数的整个区域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><code class="javascript">sayHello(); <span class="comment">// 'hello'</span>
<span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;
    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);
    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;
    	<span class="built_in">console</span>.log(<span class="string">'inner'</span>);
    &#125;
&#125;
inner(); <span class="comment">// error not defined</span></code></pre></td></tr></table></figure><p>关于第三个，window 就是一个全局变量，可以通过 this 来调用。this 算是 JS 中用的最妙的，this 是动态的，我们写了一个函数，而调用这个函数的主体是可变的，这和 Java 的继承很像。</p><p>关于作用域，有一点需要注意，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(text); <span class="comment">// undefined</span>
	<span class="keyword">var</span> text = <span class="string">'Hello'</span>;
	<span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(text);
	&#125;
	sayHello(); <span class="comment">// 'hello'</span>
&#125;
outer();
<span class="keyword">this</span>.sayHello() <span class="comment">// 'hello'</span></code></pre></td></tr></table></figure><p>结果居然是 <code>undefined =&gt; Hello =&gt; Hello</code>，undefined 很好理解，<code>text</code>定义之前是无法调用的，但是在函数外面通过 <code>this.sayHello()</code>却可以访问已经失效的变量，这说明函数（这实际上是一个闭包，之后的博客会提到）一旦建立之后，其内部的变量会被保存，以便访问的时候不会出错。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>面试官往往喜欢问一下关于函数中 this 的指代，实际上函数在调用的过程中会默认传递两个隐式参数，分别是 arguments 和 this（这两个都是带有传奇色彩的参数）。arguments 是一个伪数组，而this 的指代大概有下面几种：</p><ol><li>作为函数调用，this 指代是 window；</li><li>对象的方法，this 指代改对象；</li><li>new 构造器，经过一系列转换，this 最终的结果会赋值给创建 new 的那个变量，有个先后顺序，下面会有例子；</li><li>call 、 apply 、bind 等函数通过参数指定 this 的值。</li></ol><p>下面我自己写了一个例子，这是我在调试时候遇到的，可以总结第一条和第四条：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;
	<span class="keyword">var</span> fn = <span class="keyword">this</span>; <span class="comment">//通过 call 方法 this 指代 myObj</span>
	<span class="built_in">console</span>.log(fn.name); <span class="comment">// 'song'</span>
	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">note</span>)</span>&#123;
		<span class="built_in">console</span>.log(note); <span class="comment">// 'this is note'</span>
		<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span>
		<span class="built_in">console</span>.log(fn === myObj); <span class="comment">// true</span>
	&#125;
&#125;
<span class="keyword">var</span> myObj = &#123;
	<span class="attr">name</span> : <span class="string">'song'</span>
&#125;;
test.call(myObj)(<span class="string">'this is note'</span>);</code></pre></td></tr></table></figure><p>结果很明显，代码的执行顺序大致是：<code>myObj</code> =&gt; <code>test.call(myObj)</code> =&gt; <code>test()</code>(this是 call 来的，符合第四个规则) =&gt; <code>myObj(&quot;this is note&quot;)</code> =&gt; <code>function(note)</code>(this符合第一个规则)。</p><p>看下面分析，自己可以亲手调试一下：</p><p><img src="/content/images/2016/09/test2.png" alt=""></p><p>第二条对象的方法指代对象，其实对象的这个方法是个函数，举个例子就好理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><code class="javascript"><span class="comment">// 建立一个对象</span>
<span class="keyword">var</span> myObj=&#123;
	<span class="attr">name</span> : <span class="string">'song'</span>,
	<span class="attr">func</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;
		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// 'song'</span>
		<span class="built_in">console</span>.log(<span class="keyword">this</span> === myObj); <span class="comment">// true</span>
	&#125;,
&#125; 
myObj.func();</code></pre></td></tr></table></figure><p>对第三条的解释，先看下面的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;
	<span class="built_in">console</span>.log(<span class="keyword">this</span> === myObj) <span class="comment">// false</span>
	<span class="keyword">this</span>.name = <span class="string">'song'</span>;
&#125;
<span class="keyword">var</span> myObj = <span class="keyword">new</span> test();
<span class="built_in">console</span>.log(myObj.name); <span class="comment">// 'song'</span></code></pre></td></tr></table></figure><p>之所以 <code>this === myObj</code>会为 false，是因为new test()方法中的 this 并不是指向 myObj，它先是自己建立一个对象，把 this 指向自己，最终函数结束时候把 this 传递给myObj对象，<code>console.log(myObj.name)</code>才会有结果。</p><p><img src="/content/images/2016/09/test3.png" alt=""></p><p>并不是我们所想的 this 指向 myObj。总之，这里的 this 不是指向 window。</p><h3 id="cache-缓存，函数对象"><a href="#cache-缓存，函数对象" class="headerlink" title="cache 缓存，函数对象"></a>cache 缓存，函数对象</h3><p>如果说明函数是参数，可以传递，已经让人很兴奋，但事实上，函数还是对象，它是一个真实存在的变量。</p><p>下面是一个递归的 fibonacci 数列：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><code class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span> </span>&#123;
    <span class="keyword">if</span>(n==<span class="number">0</span> || n == <span class="number">1</span>)
        <span class="keyword">return</span> n;
    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);
&#125;</code></pre></td></tr></table></figure><p>（不讨论迭代，只考虑递归）我们知道递归会占用栈资源，当调用 1000000 次，可能会造成栈溢出。下面是一个采用函数内存的方法实现的 fibonacci 数列：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><code class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span><span class="params">(n)</span></span>&#123;
	<span class="keyword">if</span>(!fibonacci.cache) <span class="comment">//在这里先判断fibonacci.cache是否存在</span>
		fibonacci.cache=[<span class="number">0</span>,<span class="number">1</span>] <span class="comment">//默认设置 0，1</span>
	<span class="keyword">if</span>(fibonacci.cache[n] != <span class="literal">undefined</span>)
		<span class="keyword">return</span> fibonacci.cache[n];
	<span class="keyword">else</span>&#123;
		<span class="keyword">if</span>(fibonacci.cache[n<span class="number">-1</span>] === <span class="literal">undefined</span>)
			fibonacci.cache[n<span class="number">-1</span>] = fibonacci(n<span class="number">-1</span>);
		<span class="keyword">if</span>(fibonacci.cache[n<span class="number">-2</span>] === <span class="literal">undefined</span>)
			fibonacci.cache[n<span class="number">-2</span>] = fibonacci(n<span class="number">-2</span>);
		<span class="keyword">return</span> fibonacci.cache[n] = fibonacci.cache[n<span class="number">-1</span>] + fibonacci.cache[n<span class="number">-2</span>];
	&#125;
&#125;</code></pre></td></tr></table></figure><p>这种函数即对象的思路很有趣，当我们通过 <code>fibonacci(10)</code>运行 10 次之后，可以看到:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><code class="lasso">fibonacci(<span class="number">10</span>);
console.<span class="keyword">log</span>(fibonacci.<span class="keyword">cache</span>) <span class="comment">//[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span>
console.<span class="keyword">log</span>(fibonacci.name) <span class="comment">// 'fibonacci'</span></code></pre></td></tr></table></figure><p>其实除了给函数对象添加的属性之外，它自己也有自己的属性，比如 name ，arguments ， length 等。</p><p>函数的内容就写到这，共勉。</p></div><div class="pre-next clear"><div class="pre-page"><i class="pre-icon"></i> <a href="/blog/2016/09/16/8月实习总结/">8 月实习总结</a></div><div class="next-page"><a href="/blog/2016/09/07/腾讯404公益页面/">腾讯404公益页面，你中招了吗</a> <i class="next-icon"></i></div></div><div class="post-footer"><a href="/blog/rss.xml" class="post-feed" target="_black">Feed <i class="feed-icon"></i></a><h3>文档信息</h3><ul><li><span>版权声明：</span><span>自由转载-非商用-保持署名</span><a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">(创意共享3.0许可证)</a></li><li><span>发表日期：</span><span>2016-09-11 17:35:58</span></li><li><span>本文分类：</span><span> <a href="/blog/categories/JavaScript/">JavaScript</a></span></li><li><span>本文标签：</span><span> <a href="/blog/tags/JavaScript/">JavaScript</a> / <a href="/blog/tags/JS进阶/">JS进阶</a></span></li><li><span>最后编辑：</span><span>2016-10-05 22:33:28</span></li><li><span>社交媒体：</span><span><a href="https://github.com/songjinzhong">GitHub<i class="github"></i></a><a href="http://weibo.com/3822969136">微博<i class="weibo"></i></a></span></li><li><span>分享文章：</span> <span><div class="ds-share" data-thread-key="blog/2016/09/11/深入理解函数的概念/" data-title="JS 进阶之路 : 深入理解函数的概念" data-images="" data-content="之前一直觉得自己对 JavaScript 这门语言掌握的还可以，记得当初学这门语言的时候，也都是按照 Java 的思维去学的，以至于很多概念都没有弄明白。最近在 codewars 做练习的时候，才发现，原理的东西，一个都没有搞懂，JS..." data-url="http://yuren.space/blog/2016/09/11/深入理解函数的概念/"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div></span></li></ul></div><div class="page-related"><h2>相关文章</h2><ul><li><span>2016.09.28</span><a href="/blog/2016/09/28/原型链/">JS 进阶之路 : 原型链</a><p>刚学习 JavsScript 的时候，感觉它有点混乱，以前接触 C++或 ...</p></li><li><span>2016.09.24</span><a href="/blog/2016/09/24/闭包/">JS 进阶之路 : 闭包</a><p>函数在 JavaScript 中是第一型对象，而闭包的使用使其变得非常灵活...</p></li><li><span>2016.09.07</span><a href="/blog/2016/09/07/腾讯404公益页面/">腾讯404公益页面，你中招了吗</a><p>之前在别人的博客里看到了腾讯的 404 公益页面，感觉很不错，算是腾讯的良...</p></li><li><span>2016.08.14</span><a href="/blog/2016/08/14/每天一道前端面试题（定期更新）/">每天一道前端面试题（定期更新）</a><p>写在前面马上快毕业了(实际上还有一年半)，我本人倾向于前端的工作，想要加深...</p></li></ul></div><div class="duoshuo-part" id="comments"><div class="ds-thread" data-thread-key="blog/2016/09/11/深入理解函数的概念/" data-title="JS 进阶之路 : 深入理解函数的概念" data-url="http://yuren.space/blog/2016/09/11/深入理解函数的概念/"></div><style type="text/css">.ds-sync{white-space:normal}.ds-post{transition:all .3s!important}.ds-post:hover{transition:all .3s!important;border-radius:5px!important;background:#F3F3F3!important}#ds-thread #ds-reset .ds-comments{border-bottom:none;padding:15px 0}#ds-thread #ds-reset .ds-powered-by{display:none}.ds-thread .ds-loading{padding:20px 0;text-align:center;color:#AFAFAF;background-color:#EFEFEF;border-radius:5px;line-height:30px;font-style:15px}#ds-thread .ds-loading{display:none;height:0;visibility:hidden}#ds-thread #ds-reset .ds-comments{border-bottom:none}#ds-thread #ds-reset a:hover,.ds-like-panel{color:#999}#ds-reset .ds-avatar,#ds-reset .ds-avatar img{border-radius:100%}#ds-thread #ds-reset li.ds-post{border-top:none}div#ds-thread #ds-reset .ds-comment-body p{color:#000}#ds-thread #ds-reset .ds-comment-body a{color:#777!important}#ds-thread #ds-reset li.ds-tab a{text-shadow:none}#ds-thread #ds-reset .ds-sort a.ds-current,#ds-thread #ds-reset .ds-sort a:active{color:#e58c7c}#ds-thread #ds-reset .ds-post-self{border-top:none}.ds-thread-like-text{display:block}.ds-thread-cancel-like{display:none}.ds-thread-liked .ds-thread-like-text{display:none}.ds-thread-liked .ds-thread-cancel-like{display:block}#ds-thread #ds-reset img{transition:all .3s}#ds-thread #ds-reset img:hover{transform:rotate(180deg);transition:all .3s}div#ds-thread #ds-reset .ds-comment-body{color:#555}#ds-thread #ds-reset .ds-comment-body a[data-user-id='6314610027441160961']::after{content:"博主";border:1px solid #e58c7c;border-radius:2px;margin-left:4px;color:#e58c7c;padding:0 2px;font-size:12px;line-height:14px;display:inline-block}.ds-post-reply,.ds-post-repost{display:none}.ds-post-self:hover .ds-post-reply,.ds-post-self:hover .ds-post-repost{display:inline}.ds-user-name{font-size:14px!important;line-height:42px!important}.ds-children .ds-user-name{line-height:26px!important}div#ds-thread #ds-reset .ds-comment-body p{font-size:16px!important}div#ds-thread #ds-reset .ds-comment-header .ds-user-name{font-size:18px!important;font-family:consolas!important;line-height:30px!important}div#ds-thread #ds-reset .ds-textarea-wrapper textarea{height:120px!important;font-size:16px!important;font-family:Consolas,Georgia,serif}@media (max-width:800px){div#ds-thread #ds-reset .ds-textarea-wrapper textarea{height:70px!important}}div#ds-thread #ds-reset .ds-post-options{overflow:hidden}div#ds-thread #ds-reset .ds-post-toolbar{box-shadow:none}div#ds-thread #ds-reset .ds-post-button{position:relative;margin-top:20px;font-size:16px}div#ds-thread #ds-reset .ds-post-options{margin-right:0!important;border-right:1px solid #CCC}@media screen and (max-width:641px){div#ds-thread #ds-reset .ds-replybox{padding:0!important}div#ds-thread #ds-reset .ds-replybox .ds-avatar{display:none!important}.ds-post-self:hover .ds-post-reply,.ds-post-self:hover .ds-post-report,.ds-post-self:hover .ds-post-repost{display:none!important}}div#ds-thread #ds-reset .ds-comment-body p{white-space:pre-wrap;font-family:consolas!important}#ds-thread #ds-reset .ds-paginator a{font-size:20px!important}#ds-thread #ds-reset .ds-login-buttons p{color:#999}#ds-thread #ds-reset .ds-comment-body{background:#fbfbfb;padding:15px 15px 12px 32px;border-radius:5px;box-shadow:0 1px 2px rgba(0,0,0,.15),0 1px 0 rgba(255,255,255,.75) inset}</style><script type="text/javascript">var duoshuoQuery={short_name:"songjz"};!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src=("https:"==document.location.protocol?"https:":"http:")+"//static.duoshuo.com/embed.js",t.charset="UTF-8",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)}()</script></div><div class="web-info">Copyright © 2016-2017,本站由 <a href="/blog/web-info">本人</a> 手工打造,历时2周, <a href="/blog/web-info/#link">联系方式</a> <span>网站参考 <a href="http://www.barretlee.com/">小胡子哥</a>/ <a href="http://www.ruanyifeng.com/home.html">阮一峰老师</a></span></div></div><div class="tools"><i class="back-to-top" style="display:none"></i> <i class="goto-comments"></i></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/all.min.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?513bc3e28555252418b03cc8e660bc31";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-85346637-1","auto"),ga("send","pageview")</script></body></html>